# å‰ç«¯å®ç°æ–‡æ¡£

> **æ–‡æ¡£å®šä½**ï¼šå‰ç«¯æŠ€æœ¯å®ç°ç»†èŠ‚ã€æ ¸å¿ƒæ¨¡å—ã€å…³é”®ä»£ç 
> 
> **ç›¸å…³æ–‡æ¡£**ï¼š[README.md](./README.md) | [api.md](./api.md) | [backend.md](./backend.md)

---

## æ ¸å¿ƒè®¾è®¡åŸåˆ™

### å™äº‹é˜Ÿåˆ— + åª’ä½“è½¨é“æ¶æ„

å‰ç«¯é‡‡ç”¨**å™äº‹é˜Ÿåˆ—è°ƒåº¦ + åª’ä½“è½¨é“æ’­æ”¾**çš„åˆ†ç¦»æ¶æ„ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      NarrativeQueue                         â”‚
â”‚                      ï¼ˆå™äº‹é˜Ÿåˆ—ï¼‰                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ dialogue â”‚ play_    â”‚ narrationâ”‚ scene_   â”‚ dialogue â”‚  â”‚
â”‚  â”‚ (é˜»å¡)   â”‚ sound    â”‚ (é˜»å¡)   â”‚ start    â”‚ (é˜»å¡)   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚       â†“          â†“          â†“          â†“          â†“        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“          â†“          â†“          â†“
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚TextTrackâ”‚ â”‚AudioTrackâ”‚ â”‚TextTrackâ”‚ â”‚VisualTrackâ”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

| ç»„ä»¶ | èŒè´£ | è¯´æ˜ |
|------|------|------|
| **NarrativeQueue** | å™äº‹æµç¨‹è°ƒåº¦ | é¡ºåºå¤„ç†äº‹ä»¶ï¼Œå™äº‹äº‹ä»¶é˜»å¡é˜Ÿåˆ— |
| **TextTrack** | æ–‡æœ¬æ’­æ”¾ | å¯¹è¯/æ—ç™½æ–‡å­—æ¸²æŸ“ |
| **VisualTrack** | è§†è§‰æ’­æ”¾ | åœºæ™¯ã€å›¾åƒã€è§†é¢‘ |
| **AudioTrack** | éŸ³é¢‘æ’­æ”¾ | è¯­éŸ³ã€éŸ³ä¹ã€éŸ³æ•ˆã€ç¯å¢ƒéŸ³ |

### äº‹ä»¶æ ‡ç­¾ç³»ç»Ÿ

é€šè¿‡æ ‡ç­¾å±æ€§æ ‡è®°äº‹ä»¶ç‰¹æ€§ï¼Œæ”¯æŒæ‰©å±•ï¼š

```typescript
// ============================================
// è§£è€¦è®¾è®¡ï¼šäº‹ä»¶ â†’ èµ„æº â†’ è½¨é“
// ============================================

// 1. äº‹ä»¶å…ƒæ•°æ®ï¼šåªå…³å¿ƒæ˜¯å¦é˜»å¡å™äº‹é˜Ÿåˆ—
interface EventMetadata {
  narrative: boolean;  // æ˜¯å¦é˜»å¡å™äº‹é˜Ÿåˆ—ï¼ˆéœ€è¦ç­‰å¾…ç”¨æˆ·ç‚¹å‡»/AFMï¼‰
}

const EVENT_REGISTRY: Record<string, EventMetadata> = {
  // å™äº‹äº‹ä»¶ï¼ˆé˜»å¡é˜Ÿåˆ—ï¼‰
  'dialogue':    { narrative: true },
  'narration':   { narrative: true },
  'choice':      { narrative: true },
  
  // éå™äº‹äº‹ä»¶ï¼ˆä¸é˜»å¡é˜Ÿåˆ—ï¼‰
  'scene_start': { narrative: false },
  'scene_end':   { narrative: false },
  'show':        { narrative: false },
  'hide':        { narrative: false },
  'play_video':  { narrative: false },
  'play_audio':  { narrative: false },  // æ”¯æŒ channel: sound/music/ambient
  'stop_audio':  { narrative: false },
  'story_start': { narrative: false },
  'story_end':   { narrative: false },
  'chapter_start': { narrative: false },
  'chapter_end': { narrative: false },
};

// 2. èµ„æºç±»å‹ â†’ è½¨é“æ˜ å°„
type ResourceType = 'text' | 'voice' | 'image' | 'video' | 'music' | 'ambient' | 'sound' | 'background';
type TrackType = 'text' | 'visual' | 'audio';

const RESOURCE_TRACK_MAP: Record<ResourceType, TrackType> = {
  'text':       'text',
  'voice':      'audio',
  'image':      'visual',
  'video':      'visual',
  'music':      'audio',
  'ambient':    'audio',
  'sound':      'audio',
  'background': 'visual',
};

// 3. èµ„æºæ’­æ”¾å™¨æ˜ å°„ï¼ˆèµ„æºç±»å‹ â†’ å…·ä½“æ’­æ”¾æ–¹æ³•ï¼‰
interface ResourcePlayer {
  text:       (content: any) => void;
  voice:      (audio: any) => void;
  image:      (character: string, image: any) => void;
  video:      (url: string) => void;
  music:      (audio: any) => void;
  ambient:    (audio: any) => void;
  sound:      (audio: any) => void;
  background: (bg: any) => void;
}
```

### é˜»å¡è§„åˆ™

#### 1. å™äº‹é˜Ÿåˆ—é˜»å¡ï¼ˆNarrativeQueueï¼‰

| æ¡ä»¶ | é˜»å¡è¡Œä¸º |
|------|---------|
| `narrative: true` | é˜»å¡é˜Ÿåˆ—ï¼Œç­‰å¾… AFM æˆ–ç”¨æˆ·ç‚¹å‡» |
| `narrative: false` | è§¦å‘åç«‹å³å¤„ç†ä¸‹ä¸€ä¸ªäº‹ä»¶ |

#### 2. è½¨é“å†…é˜»å¡ï¼ˆç”±å„è½¨é“æ§åˆ¶ï¼‰

| è½¨é“ | èµ„æºç±»å‹ | é˜»å¡è§„åˆ™ |
|------|---------|---------|
| **TextTrack** | æ–‡æœ¬ | æ›¿æ¢å¼ï¼ˆæ–°æ–‡æœ¬æ›¿æ¢æ—§æ–‡æœ¬ï¼‰|
| **VisualTrack** | åœºæ™¯ | æ›¿æ¢å¼ |
| | å›¾åƒ | å›¾å±‚å åŠ ï¼Œä¸é˜»å¡ |
| | è§†é¢‘ | é˜»å¡ç›´åˆ°æ’­æ”¾å®Œæˆ |
| **AudioTrack** | music | æ›¿æ¢å¼ï¼Œå¾ªç¯ |
| | voice | æ›¿æ¢å¼ |
| | ambient | æ›¿æ¢å¼ï¼Œå¾ªç¯ |
| | sound | å¤šé‡æ’­æ”¾ï¼Œä¸é˜»å¡ |

### æ‰§è¡Œæµç¨‹ç¤ºä¾‹

```
äº‹ä»¶: dialogue { text: "ä½ å¥½", voice: {...}, show: {...} }

dispatchEvent å¤„ç†:
  â”œâ”€ content.text å­˜åœ¨ â†’ TextTrack.showDialogue("ä½ å¥½")
  â”œâ”€ content.voice å­˜åœ¨ â†’ AudioTrack.playVoice({...})
  â””â”€ content.show å­˜åœ¨ â†’ VisualTrack.showCharacter({...})
```

```
äº‹ä»¶åºåˆ—: [narration, play_audio, play_audio, dialogue]

NarrativeQueue å¤„ç†ï¼ˆå™äº‹é”æœºåˆ¶ï¼‰:

1. narration (narrative=true)
   â”œâ”€ å™äº‹é”å·²é‡Šæ”¾ â†’ dispatchEvent() æ ¹æ®èµ„æºåˆ†å‘
   â”‚   â”œâ”€ content.text â†’ TextTrack
   â”‚   â””â”€ content.voice â†’ AudioTrack
   â””â”€ ã€åŠ é”ã€‘
   
2. play_audio (narrative=false)
   â”œâ”€ dispatchEvent() â†’ content.audio â†’ AudioTrack
   â””â”€ ç«‹å³å¤„ç†ä¸‹ä¸€ä¸ª
   
3. play_audio (narrative=false)
   â”œâ”€ dispatchEvent() â†’ content.audio â†’ AudioTrack
   â””â”€ ç«‹å³å¤„ç†ä¸‹ä¸€ä¸ª
   
4. dialogue (narrative=true)
   â””â”€ ç­‰å¾…å™äº‹é”é‡Šæ”¾...
   
   â”€â”€â”€â”€ ç”¨æˆ·ç‚¹å‡»/AFM â†’ é‡Šæ”¾é” â”€â”€â”€â”€
   
   â””â”€ dispatchEvent() â†’ ã€åŠ é”ã€‘
```

**æ ¸å¿ƒåŸåˆ™**ï¼š
- äº‹ä»¶åªå®šä¹‰èµ„æºï¼Œä¸å…³å¿ƒè½¨é“
- èµ„æºç±»å‹å†³å®šåˆ†å‘åˆ°å“ªä¸ªè½¨é“
- narrative æ ‡ç­¾å†³å®šæ˜¯å¦é˜»å¡å™äº‹é˜Ÿåˆ—

---

## æ ¸å¿ƒæ¶æ„

### æ¶æ„å›¾

```
SSE æ¨é€ï¼ˆåç«¯ï¼‰
    â†“
DataManagerï¼ˆæ¥æ”¶äº‹ä»¶ï¼‰
    â†“
BufferControllerï¼ˆç¼“å†²æ§åˆ¶ï¼‰
    â†“
NarrativeQueueï¼ˆå™äº‹é˜Ÿåˆ—ï¼‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                       â”‚
    â”‚  é¡ºåºå¤„ç†æ‰€æœ‰äº‹ä»¶                                      â”‚
    â”‚  â”œâ”€ narrative=true  â†’ é˜»å¡ï¼ˆç­‰å¾… AFM/ç”¨æˆ·ç‚¹å‡»ï¼‰        â”‚
    â”‚  â””â”€ narrative=false â†’ è§¦å‘åç«‹å³å¤„ç†ä¸‹ä¸€ä¸ª             â”‚
    â”‚                                                       â”‚
    â”œâ”€â”€â–º TextTrackï¼ˆæ–‡æœ¬è½¨é“ï¼‰                               â”‚
    â”‚      â””â”€ æ–‡æœ¬æ¸²æŸ“ã€æ‰“å­—æœºæ•ˆæœ                           â”‚
    â”‚                                                       â”‚
    â”œâ”€â”€â–º VisualTrackï¼ˆè§†è§‰è½¨é“ï¼‰                             â”‚
    â”‚      â”œâ”€ scene â†’ æ›¿æ¢èƒŒæ™¯                              â”‚
    â”‚      â”œâ”€ image â†’ å›¾å±‚å åŠ                               â”‚
    â”‚      â””â”€ video â†’ é˜»å¡æ’­æ”¾å®Œæˆ                          â”‚
    â”‚                                                       â”‚
    â””â”€â”€â–º AudioTrackï¼ˆéŸ³é¢‘è½¨é“ï¼‰                              â”‚
           â”œâ”€ voice  â†’ æ›¿æ¢å¼                               â”‚
           â”œâ”€ music  â†’ æ›¿æ¢å¼ï¼Œå¾ªç¯                         â”‚
           â”œâ”€ ambientâ†’ æ›¿æ¢å¼ï¼Œå¾ªç¯                         â”‚
           â””â”€ sound  â†’ å¤šé‡æ’­æ”¾                             â”‚
    â†“
ç”¨æˆ·ç•Œé¢
```

### æ ¸å¿ƒæ¨¡å—

| æ¨¡å— | èŒè´£ |
|------|------|
| **EventCache** | äº‹ä»¶æŒä¹…åŒ–ç¼“å­˜ï¼ˆIndexedDBï¼‰ï¼Œæ”¯æŒç¦»çº¿æ’­æ”¾ |
| **ConnectionManager** | è¿æ¥ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼Œåˆ†é˜¶æ®µæŒ‰éœ€è¿æ¥ |
| **DataManager** | SSE è¿æ¥ç®¡ç†ï¼Œäº‹ä»¶æ¥æ”¶ |
| **BufferController** | ç¼“å†²æ§åˆ¶ï¼Œåœºæ™¯çº§ç¼“å†²ç­–ç•¥ |
| **NarrativeQueue** | å™äº‹æµç¨‹è°ƒåº¦ï¼Œé˜»å¡/éé˜»å¡æ§åˆ¶ |
| **ProgressTracker** | è¿›åº¦åŒæ­¥ï¼Œå»¶è¿Ÿå†™å…¥ä¼˜åŒ– |
| **TextTrack** | æ–‡æœ¬è½¨é“ï¼Œæ–‡å­—æ¸²æŸ“ï¼ˆæ‰“å­—æœºæ•ˆæœï¼‰|
| **VisualTrack** | è§†è§‰è½¨é“ï¼Œåœºæ™¯/å›¾åƒ/è§†é¢‘æ’­æ”¾ |
| **AudioTrack** | éŸ³é¢‘è½¨é“ï¼Œå¤šé€šé“éŸ³é¢‘ç®¡ç† |
| **ResourcePool** | èµ„æºä¸‹è½½ï¼ˆå¹¶å‘æ§åˆ¶ã€è‡ªåŠ¨é‡è¯•ï¼‰|
| **LayerManager** | å›¾å±‚ç®¡ç†ï¼ˆæ˜¾ç¤º/éšè—å…ƒç´ ï¼‰|

---

## æ¨¡å—å®ç°

### 0. EventCache - äº‹ä»¶æŒä¹…åŒ–ç¼“å­˜

**èŒè´£**ï¼šå°†äº‹ä»¶æŒä¹…åŒ–åˆ° IndexedDBï¼Œæ”¯æŒç¦»çº¿æ’­æ”¾å’Œæ–­ç‚¹ç»­ä¼ 

```typescript
interface CachedEvent {
  sequence_id: string;       // ä¸»é”®
  story_id: string;          // æ•…äº‹IDï¼ˆç´¢å¼•ï¼‰
  path_id: string;           // åˆ†æ”¯è·¯å¾„
  event_type: string;
  content: object;
  timestamp: string;
  cached_at: number;         // ç¼“å­˜æ—¶é—´æˆ³
}

class EventCache {
  private db: IDBDatabase | null = null;
  private readonly DB_NAME = 'story_events_cache';
  private readonly STORE_NAME = 'events';
  private readonly DB_VERSION = 1;

  /**
   * åˆå§‹åŒ– IndexedDB
   */
  async init(): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };
      
      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        
        if (!db.objectStoreNames.contains(this.STORE_NAME)) {
          const store = db.createObjectStore(this.STORE_NAME, { keyPath: 'sequence_id' });
          
          // ç´¢å¼•ï¼šæŒ‰æ•…äº‹æŸ¥è¯¢ï¼ŒæŒ‰åºåˆ—æ’åº
          store.createIndex('story_sequence', ['story_id', 'sequence_id'], { unique: true });
          // ç´¢å¼•ï¼šæŒ‰æ•…äº‹å’Œè·¯å¾„è¿‡æ»¤
          store.createIndex('story_path', ['story_id', 'path_id'], { unique: false });
          // ç´¢å¼•ï¼šæŒ‰ç¼“å­˜æ—¶é—´ï¼ˆç”¨äºæ¸…ç†è¿‡æœŸæ•°æ®ï¼‰
          store.createIndex('cached_at', 'cached_at', { unique: false });
        }
      };
    });
  }

  /**
   * æ‰¹é‡å­˜å‚¨äº‹ä»¶
   */
  async saveEvents(events: SSEEvent[]): Promise<void> {
    if (!this.db || events.length === 0) return;
    
    const tx = this.db.transaction(this.STORE_NAME, 'readwrite');
    const store = tx.objectStore(this.STORE_NAME);
    
    const now = Date.now();
    for (const event of events) {
      const cachedEvent: CachedEvent = {
        sequence_id: event.sequence_id,
        story_id: event.content.story_id || this.extractStoryId(event.sequence_id),
        path_id: event.path_id,
        event_type: event.event_type,
        content: event.content,
        timestamp: event.timestamp,
        cached_at: now
      };
      store.put(cachedEvent);
    }
    
    return new Promise((resolve, reject) => {
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }

  /**
   * è·å–æ•…äº‹çš„æ‰€æœ‰ç¼“å­˜äº‹ä»¶ï¼ˆæŒ‰ sequence_id æ’åºï¼‰
   */
  async getEvents(storyId: string, pathId?: string): Promise<CachedEvent[]> {
    if (!this.db) return [];
    
    const tx = this.db.transaction(this.STORE_NAME, 'readonly');
    const store = tx.objectStore(this.STORE_NAME);
    const index = pathId 
      ? store.index('story_path')
      : store.index('story_sequence');
    
    const range = pathId
      ? IDBKeyRange.only([storyId, pathId])
      : IDBKeyRange.bound([storyId, ''], [storyId, '\uffff']);
    
    return new Promise((resolve, reject) => {
      const request = index.getAll(range);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * è·å–æœ€åç¼“å­˜çš„ sequence_id
   */
  async getLastSequenceId(storyId: string): Promise<string | null> {
    const events = await this.getEvents(storyId);
    if (events.length === 0) return null;
    
    // ULID æŒ‰å­—å…¸åºæ’åºå³ä¸ºæ—¶é—´é¡ºåº
    events.sort((a, b) => b.sequence_id.localeCompare(a.sequence_id));
    return events[0].sequence_id;
  }

  /**
   * è·å–æŒ‡å®š sequence_id ä¹‹åçš„äº‹ä»¶
   */
  async getEventsAfter(storyId: string, sequenceId: string): Promise<CachedEvent[]> {
    const events = await this.getEvents(storyId);
    return events
      .filter(e => e.sequence_id > sequenceId)
      .sort((a, b) => a.sequence_id.localeCompare(b.sequence_id));
  }

  /**
   * æ¸…ç†è¿‡æœŸç¼“å­˜ï¼ˆé»˜è®¤ 7 å¤©ï¼‰
   */
  async cleanExpired(maxAge: number = 7 * 24 * 60 * 60 * 1000): Promise<void> {
    if (!this.db) return;
    
    const tx = this.db.transaction(this.STORE_NAME, 'readwrite');
    const store = tx.objectStore(this.STORE_NAME);
    const index = store.index('cached_at');
    
    const expireTime = Date.now() - maxAge;
    const range = IDBKeyRange.upperBound(expireTime);
    
    return new Promise((resolve, reject) => {
      const request = index.openCursor(range);
      request.onsuccess = (event) => {
        const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result;
        if (cursor) {
          cursor.delete();
          cursor.continue();
        }
      };
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }

  /**
   * æ¸…ç†æŒ‡å®šæ•…äº‹çš„ç¼“å­˜
   */
  async clearStoryCache(storyId: string): Promise<void> {
    if (!this.db) return;
    
    const tx = this.db.transaction(this.STORE_NAME, 'readwrite');
    const store = tx.objectStore(this.STORE_NAME);
    const index = store.index('story_sequence');
    
    const range = IDBKeyRange.bound([storyId, ''], [storyId, '\uffff']);
    
    return new Promise((resolve, reject) => {
      const request = index.openCursor(range);
      request.onsuccess = (event) => {
        const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result;
        if (cursor) {
          cursor.delete();
          cursor.continue();
        }
      };
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }

  /**
   * æ£€æŸ¥æ•…äº‹æ˜¯å¦æœ‰ç¼“å­˜
   */
  async hasCache(storyId: string): Promise<boolean> {
    const events = await this.getEvents(storyId);
    return events.length > 0;
  }

  private extractStoryId(sequenceId: string): string {
    // ä» sequence_id ä¸­æå– story_idï¼ˆå¦‚æœæœ‰å‰ç¼€çš„è¯ï¼‰
    // å¦‚æœä½¿ç”¨çº¯ ULIDï¼Œéœ€è¦ä»å…¶ä»–åœ°æ–¹è·å– story_id
    return sequenceId.split('_')[0] || '';
  }
}
```

---

### 0.1 ConnectionManager - è¿æ¥ç”Ÿå‘½å‘¨æœŸç®¡ç†

**èŒè´£**ï¼šç®¡ç†æ•…äº‹çš„è¿æ¥ç”Ÿå‘½å‘¨æœŸï¼Œå®ç°åˆ†é˜¶æ®µæŒ‰éœ€è¿æ¥ç­–ç•¥

**æ ¸å¿ƒè®¾è®¡**ï¼š
- **åˆ›ä½œé˜¶æ®µ**ï¼šçŸ­è½®è¯¢ï¼ˆ10ç§’é—´éš”ï¼‰æŸ¥è¯¢çŠ¶æ€ï¼Œä¸å»ºç«‹ SSE
- **æ¶ˆè´¹é˜¶æ®µ**ï¼šç»Ÿä¸€ç¼“å†²ç­–ç•¥ï¼Œé¦–æ¬¡/ç»§ç»­è§‚çœ‹ä½¿ç”¨ç›¸åŒé€»è¾‘
- **æ™ºèƒ½è¿æ¥**ï¼šç¼“å­˜ä¸è¶³æ—¶å»ºç«‹ SSEï¼Œç¼“å­˜å……è¶³æ—¶æ–­å¼€ SSE

**ç»Ÿä¸€ç¼“å†²ç­–ç•¥**ï¼š

é¦–æ¬¡è§‚çœ‹å’Œç»§ç»­è§‚çœ‹ä½¿ç”¨**å®Œå…¨ç›¸åŒçš„ç¼“å†²ç­–ç•¥**ï¼ŒåŒºåˆ«ä»…åœ¨äºæœ¬åœ°ç¼“å­˜çš„å‘½ä¸­æƒ…å†µï¼š

| åœºæ™¯ | ç¼“å­˜çŠ¶æ€ | è¡Œä¸º |
|------|---------|------|
| **é¦–æ¬¡è§‚çœ‹** | æ— ç¼“å­˜ | å»ºç«‹ SSEï¼Œæ¥æ”¶äº‹ä»¶å¹¶ç¼“å­˜åˆ° IndexedDB |
| **ç»§ç»­è§‚çœ‹** | æœ‰ç¼“å­˜ | ä»ç¼“å­˜è¯»å–ï¼Œç¼“å­˜ä¸è¶³æ—¶ SSE å¢é‡è¡¥å…… |

**ç¼“å­˜ç”Ÿå‘½å‘¨æœŸ**ï¼š
- ç¼“å­˜æŒä¹…åŒ–åˆ° IndexedDBï¼Œé»˜è®¤ 7 å¤©è¿‡æœŸ
- åº”ç”¨å¯åŠ¨æ—¶åå°æ¸…ç†è¿‡æœŸç¼“å­˜
- ç”¨æˆ·å¯æ‰‹åŠ¨æ¸…ç†ç‰¹å®šæ•…äº‹çš„ç¼“å­˜

```typescript
type ConnectionState = 
  | 'IDLE'           // æ— è¿æ¥
  | 'POLLING'        // åˆ›ä½œé˜¶æ®µï¼šè½®è¯¢çŠ¶æ€
  | 'STREAMING'      // æ¶ˆè´¹é˜¶æ®µï¼šSSE æ¥æ”¶ä¸­
  | 'CACHE_PLAYING'  // ä½¿ç”¨æœ¬åœ°ç¼“å­˜æ’­æ”¾
  | 'COMPLETED';     // æ•…äº‹å®Œæˆ

interface StoryStatus {
  status: 'pending' | 'generating' | 'ready' | 'dynamic' | 'completed' | 'error';
  progress: number;
  message: string;
  events_count: number;
  retry_after: number;
}

interface ConnectionManagerOptions {
  pollInterval?: number;      // è½®è¯¢é—´éš”ï¼ˆæ¯«ç§’ï¼‰ï¼Œé»˜è®¤ 10000
  highWatermark?: number;     // é«˜æ°´ä½ï¼ˆæ–­å¼€ SSEï¼‰ï¼Œé»˜è®¤ 20
  lowWatermark?: number;      // ä½æ°´ä½ï¼ˆé‡è¿ SSEï¼‰ï¼Œé»˜è®¤ 5
}

class ConnectionManager {
  private state: ConnectionState = 'IDLE';
  private storyId: string = '';
  private eventCache: EventCache;
  private dataManager: DataManager;
  private bufferController: BufferController;
  private pollTimer: number | null = null;
  
  // é…ç½®
  private pollInterval: number;
  private highWatermark: number;
  private lowWatermark: number;
  
  // å›è°ƒ
  private onStateChange?: (state: ConnectionState) => void;
  private onStatusUpdate?: (status: StoryStatus) => void;
  private onError?: (error: Error) => void;

  constructor(
    eventCache: EventCache,
    dataManager: DataManager,
    bufferController: BufferController,
    options: ConnectionManagerOptions = {}
  ) {
    this.eventCache = eventCache;
    this.dataManager = dataManager;
    this.bufferController = bufferController;
    
    this.pollInterval = options.pollInterval ?? 10000;  // 10ç§’
    this.highWatermark = options.highWatermark ?? 20;
    this.lowWatermark = options.lowWatermark ?? 5;
  }

  /**
   * å¯åŠ¨æ•…äº‹ï¼ˆæ™ºèƒ½é€‰æ‹©è¿æ¥æ–¹å¼ï¼‰
   */
  async start(storyId: string): Promise<void> {
    this.storyId = storyId;
    
    try {
      // 1. æ£€æŸ¥æ•…äº‹çŠ¶æ€
      const status = await this.fetchStatus(storyId);
      
      if (status.status === 'pending' || status.status === 'generating') {
        // åˆ›ä½œé˜¶æ®µï¼šå¯åŠ¨è½®è¯¢
        this.startPolling(storyId);
        return;
      }
      
      if (status.status === 'error') {
        this.handleError(new Error(status.message));
        return;
      }
      
      // 2. æ¶ˆè´¹é˜¶æ®µï¼šæ£€æŸ¥æœ¬åœ°ç¼“å­˜
      await this.startConsumption(storyId);
      
    } catch (error) {
      this.handleError(error as Error);
    }
  }

  /**
   * åœæ­¢æ‰€æœ‰è¿æ¥
   */
  stop(): void {
    this.stopPolling();
    this.dataManager.disconnect();
    this.setState('IDLE');
  }

  /**
   * è·å–å½“å‰çŠ¶æ€
   */
  getState(): ConnectionState {
    return this.state;
  }

  /**
   * è®¾ç½®çŠ¶æ€å˜åŒ–å›è°ƒ
   */
  setOnStateChange(callback: (state: ConnectionState) => void): void {
    this.onStateChange = callback;
  }

  /**
   * è®¾ç½®çŠ¶æ€æ›´æ–°å›è°ƒï¼ˆè½®è¯¢æœŸé—´ï¼‰
   */
  setOnStatusUpdate(callback: (status: StoryStatus) => void): void {
    this.onStatusUpdate = callback;
  }

  /**
   * è®¾ç½®é”™è¯¯å›è°ƒ
   */
  setOnError(callback: (error: Error) => void): void {
    this.onError = callback;
  }

  /**
   * é€šçŸ¥ç¼“å†²çŠ¶æ€å˜åŒ–ï¼ˆç”± BufferController è°ƒç”¨ï¼‰
   */
  onBufferLevelChange(unplayedCount: number): void {
    if (this.state === 'STREAMING' && unplayedCount >= this.highWatermark) {
      // ç¼“å­˜å……è¶³ï¼Œæ–­å¼€ SSE
      console.log(`ğŸ“¦ ç¼“å­˜å……è¶³ (${unplayedCount} >= ${this.highWatermark})ï¼Œæ–­å¼€ SSE`);
      this.pauseStreaming();
    } else if (this.state === 'CACHE_PLAYING' && unplayedCount <= this.lowWatermark) {
      // ç¼“å­˜ä¸è¶³ï¼Œé‡è¿ SSE
      console.log(`ğŸ“¦ ç¼“å­˜ä¸è¶³ (${unplayedCount} <= ${this.lowWatermark})ï¼Œé‡è¿ SSE`);
      this.resumeStreaming();
    }
  }

  // ============ ç§æœ‰æ–¹æ³• ============

  private setState(state: ConnectionState): void {
    if (this.state !== state) {
      console.log(`ğŸ”„ è¿æ¥çŠ¶æ€: ${this.state} â†’ ${state}`);
      this.state = state;
      this.onStateChange?.(state);
    }
  }

  /**
   * åˆ›ä½œé˜¶æ®µï¼šè½®è¯¢
   */
  private startPolling(storyId: string): void {
    this.setState('POLLING');
    
    const poll = async () => {
      try {
        const status = await this.fetchStatus(storyId);
        this.onStatusUpdate?.(status);
        
        if (status.status === 'ready' || status.status === 'dynamic') {
          // ç”Ÿæˆå®Œæˆï¼Œåˆ‡æ¢åˆ°æ¶ˆè´¹é˜¶æ®µ
          console.log('âœ… æ•…äº‹ç”Ÿæˆå®Œæˆï¼Œè¿›å…¥æ¶ˆè´¹é˜¶æ®µ');
          this.stopPolling();
          await this.startConsumption(storyId);
          return;
        }
        
        if (status.status === 'error') {
          this.stopPolling();
          this.handleError(new Error(status.message));
          return;
        }
        
        // ç»§ç»­è½®è¯¢ï¼ˆä½¿ç”¨æœåŠ¡ç«¯å»ºè®®çš„é—´éš”ï¼Œé»˜è®¤ 10 ç§’ï¼‰
        const interval = (status.retry_after ?? 10) * 1000;
        this.pollTimer = window.setTimeout(poll, interval);
        
      } catch (error) {
        // ç½‘ç»œé”™è¯¯ï¼Œç»§ç»­é‡è¯•
        console.warn('è½®è¯¢å¤±è´¥ï¼Œç¨åé‡è¯•:', error);
        this.pollTimer = window.setTimeout(poll, this.pollInterval);
      }
    };
    
    poll();
  }

  private stopPolling(): void {
    if (this.pollTimer !== null) {
      clearTimeout(this.pollTimer);
      this.pollTimer = null;
    }
  }

  /**
   * æ¶ˆè´¹é˜¶æ®µï¼šæ£€æŸ¥ç¼“å­˜å¹¶å†³å®šè¿æ¥ç­–ç•¥
   */
  private async startConsumption(storyId: string): Promise<void> {
    // æ£€æŸ¥æœ¬åœ°ç¼“å­˜
    const cachedEvents = await this.eventCache.getEvents(storyId);
    const lastSequenceId = await this.eventCache.getLastSequenceId(storyId);
    
    console.log(`ğŸ“‚ æœ¬åœ°ç¼“å­˜: ${cachedEvents.length} ä¸ªäº‹ä»¶`);
    
    if (cachedEvents.length > 0) {
      // æœ‰ç¼“å­˜ï¼šå…ˆæ’­æ”¾ç¼“å­˜
      this.setState('CACHE_PLAYING');
      
      // å°†ç¼“å­˜äº‹ä»¶æ¨é€åˆ° BufferController
      for (const event of cachedEvents) {
        this.bufferController.receive(event as unknown as SSEEvent);
      }
      
      // æ£€æŸ¥æ˜¯å¦éœ€è¦è¡¥å……
      const unplayedCount = this.bufferController.getUnplayedCount();
      if (unplayedCount <= this.lowWatermark) {
        // ç¼“å­˜ä¸è¶³ï¼Œå»ºç«‹ SSE å¢é‡æ¥æ”¶
        this.startStreaming(storyId, lastSequenceId);
      }
    } else {
      // æ— ç¼“å­˜ï¼šå»ºç«‹ SSE
      this.startStreaming(storyId, null);
    }
  }

  /**
   * æ¶ˆè´¹é˜¶æ®µï¼šSSE æµå¼æ¥æ”¶
   */
  private async startStreaming(storyId: string, fromSequenceId: string | null): Promise<void> {
    this.setState('STREAMING');
    
    // æ³¨å†Œäº‹ä»¶å¤„ç†
    this.dataManager.onStoryEventReceived(async (event) => {
      // ç¼“å­˜åˆ° IndexedDB
      await this.eventCache.saveEvents([event]);
      
      // æ¨é€åˆ° BufferController
      this.bufferController.receive(event);
      
      // æ£€æŸ¥æ˜¯å¦æ•…äº‹ç»“æŸ
      if (event.event_type === 'story_end') {
        this.setState('COMPLETED');
        this.dataManager.disconnect();
      }
    });
    
    // å»ºç«‹è¿æ¥
    this.dataManager.connect(storyId, fromSequenceId ?? undefined);
  }

  /**
   * æš‚åœ SSEï¼ˆç¼“å­˜å……è¶³æ—¶ï¼‰
   */
  private pauseStreaming(): void {
    this.dataManager.disconnect();
    this.setState('CACHE_PLAYING');
  }

  /**
   * æ¢å¤ SSEï¼ˆç¼“å­˜ä¸è¶³æ—¶ï¼‰
   */
  private async resumeStreaming(): Promise<void> {
    const lastSequenceId = await this.eventCache.getLastSequenceId(this.storyId);
    this.startStreaming(this.storyId, lastSequenceId);
  }

  private async fetchStatus(storyId: string): Promise<StoryStatus> {
    const response = await fetch(`/api/v1/story/${storyId}/status`);
    if (!response.ok) {
      throw new Error(`è·å–çŠ¶æ€å¤±è´¥: ${response.status}`);
    }
    const data = await response.json();
    return data.data;
  }

  private handleError(error: Error): void {
    console.error('âŒ è¿æ¥é”™è¯¯:', error);
    this.onError?.(error);
  }
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```typescript
// åº”ç”¨å¯åŠ¨æ—¶åˆå§‹åŒ–ç¼“å­˜
const eventCache = new EventCache();
await eventCache.init();

// åå°æ¸…ç†è¿‡æœŸç¼“å­˜ï¼ˆ7 å¤©ï¼‰
eventCache.cleanExpired().catch(console.warn);

const dataManager = new DataManager();
const bufferController = new BufferController(narrativeQueue, resourcePool);

const connectionManager = new ConnectionManager(eventCache, dataManager, bufferController, {
  pollInterval: 10000,   // 10ç§’è½®è¯¢
  highWatermark: 20,     // ç¼“å­˜ 20 ä¸ªäº‹ä»¶åæ–­å¼€ SSE
  lowWatermark: 5        // å‰©ä½™ 5 ä¸ªäº‹ä»¶æ—¶é‡è¿ SSE
});

// çŠ¶æ€å›è°ƒ
connectionManager.setOnStateChange((state) => {
  console.log(`è¿æ¥çŠ¶æ€: ${state}`);
  
  if (state === 'POLLING') {
    showLoadingScreen('æ­£åœ¨ç”Ÿæˆæ•…äº‹...');
  } else if (state === 'STREAMING' || state === 'CACHE_PLAYING') {
    hideLoadingScreen();
  }
});

// è½®è¯¢è¿›åº¦å›è°ƒ
connectionManager.setOnStatusUpdate((status) => {
  updateProgressBar(status.progress);
  updateStatusMessage(status.message);
});

// é”™è¯¯å›è°ƒ
connectionManager.setOnError((error) => {
  showErrorNotification(error.message);
});

// ç¼“å†²æ§åˆ¶å™¨é€šçŸ¥è¿æ¥ç®¡ç†å™¨
bufferController.setOnBufferLevelChange((count) => {
  connectionManager.onBufferLevelChange(count);
});

// å¯åŠ¨æ•…äº‹
await connectionManager.start('story_001');

// ç”¨æˆ·é€€å‡ºæ—¶
window.addEventListener('beforeunload', () => {
  connectionManager.stop();
});
```

#### ç»Ÿä¸€ç¼“å†²ç­–ç•¥ï¼šç¼“å­˜å‘½ä¸­ä¸æœªå‘½ä¸­

**æ ¸å¿ƒåŸåˆ™**ï¼šé¦–æ¬¡è§‚çœ‹å’Œç»§ç»­è§‚çœ‹ä½¿ç”¨**å®Œå…¨ç›¸åŒçš„ç¼“å†²ç­–ç•¥**ï¼ŒåŒºåˆ«ä»…åœ¨äºæœ¬åœ°ç¼“å­˜çš„å‘½ä¸­æƒ…å†µï¼š

| åœºæ™¯ | ç¼“å­˜çŠ¶æ€ | ç¼“å†²è¡Œä¸º | ç”¨æˆ·ä½“éªŒ |
|------|---------|---------|---------|
| **ç»§ç»­è§‚çœ‹** | æœ‰ç¼“å­˜ | ç›´æ¥ä» IndexedDB è¯»å– | ç§’æ’­ï¼Œç«‹å³ä»ä¸Šæ¬¡ä½ç½®å¼€å§‹ |
| **é¦–æ¬¡è§‚çœ‹** | æ— ç¼“å­˜ | å»ºç«‹ SSE æ¥æ”¶å¹¶ç¼“å­˜ | å¯é€‰å±•ç¤ºåºå¹•æ©ç›–åŠ è½½ |

**ç­–ç•¥ç»Ÿä¸€æ€§**ï¼š
- ä¸¤ç§åœºæ™¯éƒ½ä½¿ç”¨ç›¸åŒçš„é«˜ä½æ°´ä½æ§åˆ¶
- ä¸¤ç§åœºæ™¯éƒ½ä¼šå°†äº‹ä»¶æŒä¹…åŒ–åˆ° IndexedDB
- ä¸¤ç§åœºæ™¯éƒ½æ”¯æŒæ–­ç‚¹ç»­ä¼ 

**åºå¹•åŠ è½½ï¼ˆå¯é€‰ï¼‰**ï¼šé¦–æ¬¡è§‚çœ‹æ—¶å¯å±•ç¤ºåºå¹•ç•Œé¢æ©ç›–åˆå§‹ç¼“å†²ï¼Œè¿™æ˜¯ç”¨æˆ·ä½“éªŒä¼˜åŒ–è€Œéæ ¸å¿ƒç­–ç•¥ã€‚

```typescript
interface StoryMeta {
  story_id: string;
  title: string;
  logline: string;
  themes: {
    genre: string;
    tone: string;
  };
  characters: Array<{
    name: string;
    avatar_url?: string;
  }>;
}

class PlayPageController {
  private connectionManager: ConnectionManager;
  private eventCache: EventCache;
  private prologueUI: PrologueUI;
  
  /**
   * è¿›å…¥æ’­æ”¾é¡µé¢
   */
  async enterPlayPage(storyId: string, storyMeta: StoryMeta): Promise<void> {
    // 1. æ£€æŸ¥æœ¬åœ°ç¼“å­˜
    const cachedEvents = await this.eventCache.getEvents(storyId);
    const hasCached = cachedEvents.length > 0;
    
    if (hasCached) {
      // ç»§ç»­è§‚çœ‹ï¼šç§’æ’­
      await this.startImmediate(storyId, cachedEvents);
    } else {
      // é¦–æ¬¡è§‚çœ‹ï¼šåºå¹•åŠ è½½
      await this.startWithPrologue(storyId, storyMeta);
    }
  }
  
  /**
   * ç»§ç»­è§‚çœ‹ï¼šç§’æ’­ï¼ˆæœ‰ç¼“å­˜ï¼‰
   */
  private async startImmediate(storyId: string, cachedEvents: CachedEvent[]): Promise<void> {
    console.log('ğŸ¬ ç»§ç»­è§‚çœ‹ - ç§’æ’­æ¨¡å¼');
    
    // è¯»å–ä¸Šæ¬¡è¿›åº¦
    const progress = await this.getLocalProgress(storyId);
    
    // ç«‹å³å¼€å§‹æ’­æ”¾
    this.narrativeQueue.loadFromCache(cachedEvents, progress.current_sequence_id);
    this.narrativeQueue.play();
    
    // åå°æ£€æŸ¥æ˜¯å¦éœ€è¦è¡¥å……æ›´å¤šäº‹ä»¶
    const unplayedCount = this.bufferController.getUnplayedCount();
    if (unplayedCount <= 5) {
      await this.connectionManager.start(storyId);
    }
  }
  
  /**
   * é¦–æ¬¡è§‚çœ‹ï¼šåºå¹•åŠ è½½ï¼ˆæ— ç¼“å­˜ï¼‰
   */
  private async startWithPrologue(storyId: string, storyMeta: StoryMeta): Promise<void> {
    console.log('ğŸ¬ é¦–æ¬¡è§‚çœ‹ - åºå¹•åŠ è½½æ¨¡å¼');
    
    // 1. æ˜¾ç¤ºåºå¹•ç•Œé¢
    this.prologueUI.show({
      title: storyMeta.title,
      logline: storyMeta.logline,
      genre: storyMeta.themes.genre,
      tone: storyMeta.themes.tone,
      characters: storyMeta.characters
    });
    
    // 2. åå°å¼€å§‹åŠ è½½
    const bufferReady = new Promise<void>((resolve) => {
      this.bufferController.setOnBufferReady(() => resolve());
    });
    
    await this.connectionManager.start(storyId);
    
    // 3. ç­‰å¾…ç”¨æˆ·ç‚¹å‡»"å¼€å§‹"æˆ–åºå¹•åŠ¨ç”»ç»“æŸ
    const userReady = this.prologueUI.waitForStart();
    
    // 4. ä¸¤ä¸ªæ¡ä»¶éƒ½æ»¡è¶³åå¼€å§‹æ’­æ”¾
    await Promise.all([bufferReady, userReady]);
    
    // 5. éšè—åºå¹•ï¼Œå¼€å§‹æ­£å¼æ’­æ”¾
    this.prologueUI.hide();
    this.narrativeQueue.play();
  }
}
```

#### åºå¹•ç•Œé¢ï¼ˆPrologueUIï¼‰

```typescript
interface PrologueData {
  title: string;
  logline: string;
  genre: string;
  tone: string;
  characters: Array<{ name: string; avatar_url?: string }>;
}

class PrologueUI {
  private container: HTMLElement;
  private startButton: HTMLButtonElement;
  private startPromise: Promise<void> | null = null;
  private startResolve: (() => void) | null = null;
  
  /**
   * æ˜¾ç¤ºåºå¹•ç•Œé¢
   */
  show(data: PrologueData): void {
    // æ¸²æŸ“åºå¹•å†…å®¹
    this.container.innerHTML = `
      <div class="prologue">
        <div class="prologue-backdrop"></div>
        <div class="prologue-content">
          <h1 class="prologue-title">${data.title}</h1>
          <p class="prologue-genre">${data.genre} Â· ${data.tone}</p>
          <p class="prologue-logline">${data.logline}</p>
          ${this.renderCharacters(data.characters)}
          <button class="prologue-start-btn">å¼€å§‹æ•…äº‹</button>
          <div class="prologue-loading">
            <span class="loading-spinner"></span>
            <span class="loading-text">æ­£åœ¨å‡†å¤‡...</span>
          </div>
        </div>
      </div>
    `;
    
    this.container.classList.add('visible');
    
    // æ’­æ”¾æ°›å›´éŸ³ä¹ï¼ˆå¯é€‰ï¼‰
    this.playAmbientMusic(data.genre);
    
    // å¯åŠ¨åºå¹•åŠ¨ç”»
    this.startAnimation();
  }
  
  /**
   * ç­‰å¾…ç”¨æˆ·ç‚¹å‡»å¼€å§‹
   */
  waitForStart(): Promise<void> {
    this.startPromise = new Promise((resolve) => {
      this.startResolve = resolve;
      
      // ç»‘å®šæŒ‰é’®ç‚¹å‡»
      this.startButton = this.container.querySelector('.prologue-start-btn')!;
      this.startButton.addEventListener('click', () => {
        this.startResolve?.();
      });
      
      // æˆ–è€…ç­‰å¾…åŠ¨ç”»å®Œæˆåè‡ªåŠ¨å¼€å§‹ï¼ˆ5ç§’ï¼‰
      setTimeout(() => {
        this.startResolve?.();
      }, 5000);
    });
    
    return this.startPromise;
  }
  
  /**
   * æ›´æ–°åŠ è½½çŠ¶æ€
   */
  updateLoadingStatus(message: string, ready: boolean): void {
    const loadingText = this.container.querySelector('.loading-text');
    if (loadingText) {
      loadingText.textContent = message;
    }
    
    if (ready) {
      this.startButton.disabled = false;
      this.startButton.textContent = 'å¼€å§‹æ•…äº‹';
    }
  }
  
  /**
   * éšè—åºå¹•
   */
  hide(): void {
    this.container.classList.add('fade-out');
    setTimeout(() => {
      this.container.classList.remove('visible', 'fade-out');
    }, 500);
  }
  
  private renderCharacters(characters: Array<{ name: string; avatar_url?: string }>): string {
    if (!characters.length) return '';
    
    return `
      <div class="prologue-characters">
        ${characters.slice(0, 3).map(c => `
          <div class="character-card">
            ${c.avatar_url ? `<img src="${c.avatar_url}" alt="${c.name}">` : ''}
            <span>${c.name}</span>
          </div>
        `).join('')}
      </div>
    `;
  }
  
  private startAnimation(): void {
    // æ ‡é¢˜æ·¡å…¥ã€æ–‡å­—é€æ­¥æ˜¾ç¤ºç­‰åŠ¨ç”»æ•ˆæœ
    const elements = this.container.querySelectorAll('.prologue-content > *');
    elements.forEach((el, i) => {
      (el as HTMLElement).style.animationDelay = `${i * 0.3}s`;
    });
  }
  
  private playAmbientMusic(genre: string): void {
    // æ ¹æ®ç±»å‹æ’­æ”¾å¯¹åº”çš„æ°›å›´éŸ³ä¹
    // å¯é€‰åŠŸèƒ½
  }
}
```

**åºå¹•è®¾è®¡è¦ç‚¹**ï¼š
- ğŸ¨ **è§†è§‰æ°›å›´**ï¼šèƒŒæ™¯æ¨¡ç³Š/æ¸å˜ï¼Œè¥é€ æ²‰æµ¸æ„Ÿ
- â±ï¸ **æ—¶é—´æ§åˆ¶**ï¼š3-5 ç§’ï¼Œè¶³å¤Ÿç¼“å†²ä½†ä¸è¿‡é•¿
- ğŸµ **éŸ³ä¹é¢„çƒ­**ï¼šå¯é€‰æ’­æ”¾èƒŒæ™¯éŸ³ä¹
- ğŸ“± **äº¤äº’åé¦ˆ**ï¼šåŠ è½½çŠ¶æ€ â†’ å‡†å¤‡å°±ç»ª â†’ å¼€å§‹æŒ‰é’®æ¿€æ´»

---

### 0.2 DataManager - SSE è¿æ¥ç®¡ç†

**èŒè´£**ï¼šè¿æ¥ SSEï¼Œæ¥æ”¶äº‹ä»¶ï¼ŒæŒ‰äº‹ä»¶ç±»å‹åˆ†å‘

```typescript
class DataManager {
  private eventSource: EventSource | null = null;
  private onStoryEvent?: (event: SSEEvent) => void;
  private onSystemEvent?: (event: SSEEvent) => void;

  /**
   * è¿æ¥ SSE ç«¯ç‚¹
   */
  connect(storyId: string, fromSequenceId?: string): void {
    const url = fromSequenceId
      ? `/api/v1/story/${storyId}/stream?from_sequence_id=${fromSequenceId}`
      : `/api/v1/story/${storyId}/stream`;

    this.eventSource = new EventSource(url);

    // ç›‘å¬ story_eventï¼ˆæ•…äº‹å†…å®¹äº‹ä»¶ï¼‰
    this.eventSource.addEventListener('story_event', (e) => {
      const event: SSEEvent = JSON.parse(e.data);
      console.log(`ğŸ“– æ”¶åˆ° Story äº‹ä»¶: ${event.event_type}`);
      
      if (this.onStoryEvent) {
        this.onStoryEvent(event);
      }
    });

    // ç›‘å¬ system_eventï¼ˆç³»ç»ŸçŠ¶æ€äº‹ä»¶ï¼‰
    this.eventSource.addEventListener('system_event', (e) => {
      const event: SSEEvent = JSON.parse(e.data);
      console.log(`âš™ï¸ æ”¶åˆ° System äº‹ä»¶: ${event.event_type}`);
      
      if (this.onSystemEvent) {
        this.onSystemEvent(event);
      }
    });

    // è¿æ¥æ‰“å¼€
    this.eventSource.onopen = () => {
      console.log('âœ… SSE è¿æ¥å·²å»ºç«‹');
    };

    // è¿æ¥é”™è¯¯
    this.eventSource.onerror = (error) => {
      console.error('âŒ SSE è¿æ¥é”™è¯¯:', error);
      // æµè§ˆå™¨ä¼šè‡ªåŠ¨é‡è¿
    };
  }

  /**
   * æ³¨å†Œ Story äº‹ä»¶å¤„ç†å™¨
   */
  onStoryEventReceived(handler: (event: SSEEvent) => void): void {
    this.onStoryEvent = handler;
  }

  /**
   * æ³¨å†Œ System äº‹ä»¶å¤„ç†å™¨
   */
  onSystemEventReceived(handler: (event: SSEEvent) => void): void {
    this.onSystemEvent = handler;
  }

  /**
   * æ–­å¼€è¿æ¥
   */
  disconnect(): void {
    if (this.eventSource) {
      this.eventSource.close();
      this.eventSource = null;
    }
  }
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```typescript
// ä»ç”¨æˆ·è®¾ç½®è¯»å–éŸ³é‡é…ç½®
const userSettings = await getUserSettings();
const volumeConfig: AudioGlobalConfig = {
  voice_volume: userSettings.voice_volume,
  music_volume: userSettings.music_volume,
  sound_volume: userSettings.sound_volume,
  ambient_volume: userSettings.ambient_volume
};

// åˆå§‹åŒ–å„ç»„ä»¶
const resourcePool = new ResourcePool({ maxConcurrent: 6 });
const layerManager = new LayerManager();
const textTrack = new TextTrack();
const visualTrack = new VisualTrack(resourcePool, layerManager);
const audioTrack = new AudioTrack(resourcePool, volumeConfig);

// å™äº‹é˜Ÿåˆ—ï¼ˆæ ¸å¿ƒè°ƒåº¦å™¨ï¼‰
const narrativeQueue = new NarrativeQueue({
  textTrack,
  visualTrack,
  audioTrack,
  resourcePool
});

// ä»ç”¨æˆ·è®¾ç½®é…ç½®å™äº‹é˜Ÿåˆ—
narrativeQueue.setAFM(userSettings.afm_enable, userSettings.afm_time);
narrativeQueue.setChoiceTimeout(userSettings.choice_timeout);

// ç¼“å†²æ§åˆ¶å™¨ï¼ˆé…ç½®ç¼“å†²å¤§å°ï¼‰
const bufferController = new BufferController(narrativeQueue, resourcePool, {
  narrativeBufferSize: 10  // ç¼“å­˜10ä¸ªå™äº‹äº‹ä»¶åå¼€å§‹æ’­æ”¾ï¼ˆé»˜è®¤å€¼ï¼‰
});

// ç¼“å†²çŠ¶æ€å˜åŒ–å›è°ƒï¼ˆæ›´æ–° UIï¼‰
bufferController.setOnStateChange((state) => {
  if (state === 'buffering') {
    showLoadingScreen('æ­£åœ¨åŠ è½½...');
  } else if (state === 'waiting') {
    showLoadingScreen('ç¼“å†²ä¸­...');
  } else {
    hideLoadingScreen();
  }
});

// å™äº‹é˜Ÿåˆ—ç©ºæ—¶é€šçŸ¥ç¼“å†²æ§åˆ¶å™¨
narrativeQueue.setOnQueueEmpty(() => {
  bufferController.onBufferEmpty();
});

const dataManager = new DataManager();

// Story äº‹ä»¶ â†’ ç¼“å†²æ§åˆ¶å™¨
dataManager.onStoryEventReceived((event) => {
  bufferController.receive(event);
});

// System äº‹ä»¶ â†’ æ›´æ–°UIçŠ¶æ€
dataManager.onSystemEventReceived((event) => {
  if (event.event_type === 'heartbeat') {
    updateConnectionStatus('active');
  } else if (event.event_type === 'error') {
    showErrorNotification(event.content.message);
  }
});

// è¿æ¥
dataManager.connect('story_001');

// å¤„ç†ç”¨æˆ·é€‰æ‹©ï¼ˆåˆ†æ”¯è·³è½¬ï¼‰
narrativeQueue.setOnChoice(async (selectedOption) => {
  // ä»é€‰é¡¹ä¸­è·å–ç›®æ ‡åˆ†æ”¯çš„ path_id
  const targetPathId = selectedOption.path_id;
  
  // åˆ‡æ¢å½“å‰æ’­æ”¾è·¯å¾„ï¼ˆæ ¸å¿ƒï¼ï¼‰
  // åˆ‡æ¢åï¼Œåç»­åŒ¹é…è¯¥ path_id çš„äº‹ä»¶å°†è¢«æ’­æ”¾
  // å¦‚æœè¯¥åˆ†æ”¯å·²é¢„ç”Ÿæˆï¼Œèµ„æºå·²ä¸‹è½½ï¼Œç«‹å³æ— ç¼æ’­æ”¾
  bufferController.switchPath(targetPathId);
  
  // é€šçŸ¥åç«¯ç”¨æˆ·é€‰æ‹©ï¼ˆè®°å½•è¿›åº¦ã€è§¦å‘æœªç”Ÿæˆåˆ†æ”¯çš„ç”Ÿæˆï¼‰
  await api.post(`/story/${storyId}/choice`, {
    option_id: selectedOption.option_id
  });
  
  console.log(`ç”¨æˆ·é€‰æ‹©åˆ†æ”¯: ${selectedOption.option_id}, åˆ‡æ¢è·¯å¾„: ${targetPathId}`);
});
```

---

### 0.3 BufferController - ç¼“å†²æ§åˆ¶å™¨

**èŒè´£**ï¼šæ§åˆ¶æ’­æ”¾æ—¶æœºï¼Œç¡®ä¿æœ‰è¶³å¤Ÿçš„ç¼“å†²é¿å…å¡é¡¿ï¼›ç®¡ç†åˆ†æ”¯è·¯å¾„è¿‡æ»¤

**æ ¸å¿ƒè®¾è®¡**ï¼š
- **path_id è¿‡æ»¤**ï¼šåªæ’­æ”¾åŒ¹é… `currentPathId` çš„äº‹ä»¶ï¼Œå…¶ä»–åˆ†æ”¯äº‹ä»¶ä»…é¢„ä¸‹è½½èµ„æº
- **ç»Ÿä¸€æ¨¡å‹**ï¼šçº¿æ€§å™äº‹å’Œäº’åŠ¨å™äº‹ä½¿ç”¨ç›¸åŒé€»è¾‘ï¼ˆçº¿æ€§å™äº‹ path_id æ’ä¸º `"root0000"`ï¼‰

**ç¼“å†²ç­–ç•¥ï¼ˆäº‹ä»¶çº§ç¼“å†²ï¼‰**ï¼š
- **åˆå§‹ç¼“å†²**ï¼šç¼“å­˜ N ä¸ª**å½“å‰è·¯å¾„çš„**å™äº‹äº‹ä»¶ OR é‡åˆ°ç¬¬ä¸€ä¸ª choice äº‹ä»¶åå¼€å§‹æ’­æ”¾
- **è¿½èµ¶ç¼“å†²**ï¼šæ’­æ”¾é€Ÿåº¦è¶…è¿‡ç”Ÿäº§é€Ÿåº¦æ—¶æš‚åœï¼Œç¼“å­˜ N ä¸ªå™äº‹äº‹ä»¶ OR é‡åˆ° choice äº‹ä»¶åç»§ç»­
- **N é»˜è®¤å€¼**ï¼š10ï¼ˆå¯é…ç½®ï¼‰

**å™äº‹äº‹ä»¶å®šä¹‰**ï¼š`dialogue`ã€`narration`ã€`choice`ï¼ˆå³ `narrative: true` çš„äº‹ä»¶ï¼‰

```typescript
type BufferState = 'buffering' | 'playing' | 'waiting';

// äº‹ä»¶ç±»å‹æ³¨å†Œè¡¨ï¼ˆåˆ¤æ–­æ˜¯å¦ä¸ºå™äº‹äº‹ä»¶ï¼‰
const NARRATIVE_EVENTS = new Set(['dialogue', 'narration', 'choice']);

interface BufferControllerOptions {
  narrativeBufferSize?: number;  // å™äº‹äº‹ä»¶ç¼“å†²æ•°é‡ï¼Œé»˜è®¤ 10
}

class BufferController {
  private state: BufferState = 'buffering';
  private eventBuffer: SSEEvent[] = [];
  private narrativeQueue: NarrativeQueue;
  private resourcePool: ResourcePool;
  private onStateChange?: (state: BufferState) => void;
  
  // ç¼“å†²é…ç½®
  private narrativeBufferSize: number;
  
  // ç»Ÿè®¡ç¼“å†²åŒºä¸­çš„å™äº‹äº‹ä»¶æ•°é‡ï¼ˆä»…å½“å‰è·¯å¾„ï¼‰
  private narrativeEventCount = 0;
  
  // å½“å‰æ’­æ”¾è·¯å¾„ï¼ˆçº¿æ€§å™äº‹æ’ä¸º "root0000"ï¼Œäº’åŠ¨å™äº‹é€‰æ‹©ååˆ‡æ¢ï¼‰
  private currentPathId: string = 'root0000';

  constructor(
    narrativeQueue: NarrativeQueue, 
    resourcePool: ResourcePool,
    options: BufferControllerOptions = {}
  ) {
    this.narrativeQueue = narrativeQueue;
    this.resourcePool = resourcePool;
    this.narrativeBufferSize = options.narrativeBufferSize ?? 10;
  }

  /**
   * æ¥æ”¶äº‹ä»¶ï¼ˆæ¥è‡ª DataManagerï¼‰
   * 
   * å¤„ç†é€»è¾‘ï¼š
   * 1. å§‹ç»ˆé¢„åŠ è½½èµ„æºï¼ˆæ— è®ºå“ªä¸ªåˆ†æ”¯ï¼‰
   * 2. åªæœ‰ path_id åŒ¹é…çš„äº‹ä»¶æ‰åŠ å…¥ç¼“å†²åŒº
   * 3. å…¶ä»–åˆ†æ”¯çš„äº‹ä»¶ä»…ä¸‹è½½èµ„æºï¼Œä¸æ’­æ”¾
   */
  receive(event: SSEEvent): void {
    // å§‹ç»ˆé¢„åŠ è½½èµ„æºï¼ˆåŒ…æ‹¬å…¶ä»–åˆ†æ”¯ï¼Œä¿è¯é€‰æ‹©åæ— å»¶è¿Ÿï¼‰
    this.preloadResources(event);
    
    // åªå¤„ç†å½“å‰è·¯å¾„çš„äº‹ä»¶
    if (event.path_id !== this.currentPathId) {
      console.log(`ğŸ”€ è·³è¿‡éå½“å‰è·¯å¾„äº‹ä»¶: ${event.path_id} (å½“å‰: ${this.currentPathId})`);
      return;
    }
    
    // åŠ å…¥ç¼“å†²åŒº
    this.eventBuffer.push(event);
    
    // å¦‚æœæ˜¯å™äº‹äº‹ä»¶ï¼Œå¢åŠ è®¡æ•°
    if (NARRATIVE_EVENTS.has(event.event_type)) {
      this.narrativeEventCount++;
      // é€šçŸ¥ç¼“å†²æ°´ä½å˜åŒ–
      this.notifyBufferLevelChange();
    }
    
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥å¼€å§‹/ç»§ç»­æ’­æ”¾
    this.checkBufferReady(event);
  }

  /**
   * åˆ‡æ¢å½“å‰æ’­æ”¾è·¯å¾„ï¼ˆç”¨æˆ·é€‰æ‹©åˆ†æ”¯æ—¶è°ƒç”¨ï¼‰
   * 
   * @param pathId æ–°çš„è·¯å¾„ID
   */
  switchPath(pathId: string): void {
    console.log(`ğŸ”€ åˆ‡æ¢è·¯å¾„: ${this.currentPathId} â†’ ${pathId}`);
    this.currentPathId = pathId;
    
    // å¦‚æœå½“å‰æœ‰æ–°è·¯å¾„çš„ç¼“å†²äº‹ä»¶ï¼ˆé¢„ç”Ÿæˆçš„ï¼‰ï¼Œç«‹å³å¤„ç†
    // æ³¨æ„ï¼šç”±äºä¹‹å‰çš„äº‹ä»¶å·²è¢«è·³è¿‡ï¼Œéœ€è¦ä» DataManager çš„å†å²ä¸­é‡æ–°è·å–
    // å®é™…å®ç°ä¸­å¯èƒ½éœ€è¦ DataManager ç»´æŠ¤ä¸€ä¸ªå…¨é‡äº‹ä»¶ç¼“å­˜
  }

  /**
   * è·å–å½“å‰è·¯å¾„ID
   */
  getCurrentPathId(): string {
    return this.currentPathId;
  }

  /**
   * è·å–æœªæ’­æ”¾çš„å™äº‹äº‹ä»¶æ•°é‡ï¼ˆä¾› ConnectionManager ä½¿ç”¨ï¼‰
   */
  getUnplayedCount(): number {
    return this.narrativeEventCount + this.narrativeQueue.getQueueLength();
  }

  /**
   * è®¾ç½®ç¼“å†²æ°´ä½å˜åŒ–å›è°ƒï¼ˆä¾› ConnectionManager ä½¿ç”¨ï¼‰
   */
  setOnBufferLevelChange(callback: (count: number) => void): void {
    this.onBufferLevelChange = callback;
  }

  private onBufferLevelChange?: (count: number) => void;

  /**
   * é€šçŸ¥ç¼“å†²æ°´ä½å˜åŒ–
   */
  private notifyBufferLevelChange(): void {
    if (this.onBufferLevelChange) {
      const count = this.getUnplayedCount();
      this.onBufferLevelChange(count);
    }
  }

  /**
   * æ£€æŸ¥ç¼“å†²åŒºæ˜¯å¦å°±ç»ª
   * 
   * è§¦å‘æ¡ä»¶ï¼š
   * 1. ç¼“å­˜äº† N ä¸ªå™äº‹äº‹ä»¶
   * 2. é‡åˆ° choice äº‹ä»¶ï¼ˆåˆ†æ”¯é€‰é¡¹ä¼šé˜»å¡æ’­æ”¾ï¼‰
   */
  private checkBufferReady(event: SSEEvent): void {
    const isBufferReady = 
      this.narrativeEventCount >= this.narrativeBufferSize || 
      event.event_type === 'choice';
    
    if (!isBufferReady) {
      return;
    }
    
    if (this.state === 'buffering') {
      console.log(`ğŸ“¦ åˆå§‹ç¼“å†²å®Œæˆï¼ˆå™äº‹äº‹ä»¶: ${this.narrativeEventCount}ï¼‰ï¼Œå¼€å§‹æ’­æ”¾`);
      this.state = 'playing';
      this.flushBuffer();
      this.onStateChange?.('playing');
    } else if (this.state === 'waiting') {
      console.log(`ğŸ“¦ è¿½èµ¶ç¼“å†²å®Œæˆï¼ˆå™äº‹äº‹ä»¶: ${this.narrativeEventCount}ï¼‰ï¼Œç»§ç»­æ’­æ”¾`);
      this.state = 'playing';
      this.flushBuffer();
      this.narrativeQueue.resume();
      this.onStateChange?.('playing');
    }
  }

  /**
   * åˆ†å‘ç¼“å†²åŒºä¸­çš„æ‰€æœ‰äº‹ä»¶åˆ°å™äº‹é˜Ÿåˆ—
   */
  private flushBuffer(): void {
    while (this.eventBuffer.length > 0) {
      const event = this.eventBuffer.shift()!;
      this.narrativeQueue.enqueue(event);
    }
    // é‡ç½®è®¡æ•°
    this.narrativeEventCount = 0;
    // é€šçŸ¥ç¼“å†²æ°´ä½å˜åŒ–
    this.notifyBufferLevelChange();
  }

  /**
   * å™äº‹é˜Ÿåˆ—é€šçŸ¥ï¼šé˜Ÿåˆ—ç©º
   */
  onBufferEmpty(): void {
    if (this.state === 'playing') {
      console.log('â³ æ’­æ”¾é€Ÿåº¦è¶…è¿‡ç”Ÿäº§é€Ÿåº¦ï¼Œç­‰å¾…ç¼“å†²...');
      this.state = 'waiting';
      this.narrativeQueue.pause();
      this.onStateChange?.('waiting');
    }
  }

  /**
   * é¢„åŠ è½½äº‹ä»¶æ‰€éœ€èµ„æºï¼ˆæ— è®ºå“ªä¸ªåˆ†æ”¯éƒ½é¢„åŠ è½½ï¼‰
   */
  private preloadResources(event: SSEEvent): void {
    const urls = this.extractResourceUrls(event);
    urls.forEach(({ url, type }) => {
      this.resourcePool.download(url, type);
    });
  }

  private extractResourceUrls(event: SSEEvent): Array<{url: string, type: ResourceType}> {
    const urls: Array<{url: string, type: ResourceType}> = [];
    
    if (event.content?.show?.url) {
      // é€šè¿‡æ–‡ä»¶æ‰©å±•ååˆ¤æ–­èµ„æºç±»å‹
      const isVideo = this.isVideoUrl(event.content.show.url);
      urls.push({ 
        url: event.content.show.url, 
        type: isVideo ? 'video' : 'image' 
      });
    }
    if (event.content?.voice?.url) {
      urls.push({ url: event.content.voice.url, type: 'audio' });
    }
    if (event.content?.audio?.url) {
      urls.push({ url: event.content.audio.url, type: 'audio' });
    }
    if (event.content?.background?.url) {
      urls.push({ url: event.content.background.url, type: 'image' });
    }
    if (event.content?.music?.url) {
      urls.push({ url: event.content.music.url, type: 'audio' });
    }
    if (event.content?.ambient?.url) {
      urls.push({ url: event.content.ambient.url, type: 'audio' });
    }
    
    return urls;
  }

  setOnStateChange(callback: (state: BufferState) => void): void {
    this.onStateChange = callback;
  }

  getState(): BufferState {
    return this.state;
  }

  /**
   * é€šè¿‡URLæ‰©å±•ååˆ¤æ–­æ˜¯å¦ä¸ºè§†é¢‘
   */
  private isVideoUrl(url: string): boolean {
    const videoExtensions = ['.webm', '.mp4', '.ogv'];
    const urlLower = url.toLowerCase();
    return videoExtensions.some(ext => urlLower.includes(ext));
  }
}
```

---

### 0.2 NarrativeQueue - å™äº‹é˜Ÿåˆ—

**èŒè´£**ï¼šå™äº‹æµç¨‹è°ƒåº¦ï¼Œé¡ºåºå¤„ç†æ‰€æœ‰äº‹ä»¶ï¼Œæ ¹æ®äº‹ä»¶æ ‡ç­¾å†³å®šé˜»å¡è¡Œä¸º

**æ ¸å¿ƒé€»è¾‘**ï¼š
- `narrative: true` â†’ é˜»å¡é˜Ÿåˆ—ï¼ˆç­‰å¾… AFM æˆ–ç”¨æˆ·ç‚¹å‡»ï¼‰
- `narrative: false` â†’ è§¦å‘åç«‹å³å¤„ç†ä¸‹ä¸€ä¸ªäº‹ä»¶

```typescript
// äº‹ä»¶å…ƒæ•°æ®
interface EventMetadata {
  narrative: boolean;  // æ˜¯å¦é˜»å¡å™äº‹é˜Ÿåˆ—
}

// äº‹ä»¶ç±»å‹æ³¨å†Œè¡¨
const EVENT_REGISTRY: Record<string, EventMetadata> = {
  // å™äº‹äº‹ä»¶ï¼ˆé˜»å¡é˜Ÿåˆ—ï¼‰
  'dialogue':    { narrative: true },
  'narration':   { narrative: true },
  'choice':      { narrative: true },
  
  // è§†é¢‘äº‹ä»¶ï¼ˆè§†è§‰è½¨é“å†…æ›¿æ¢å¼ï¼Œä¸é˜»å¡å™äº‹é˜Ÿåˆ—ï¼‰
  'play_video':  { narrative: false },
  
  // éå™äº‹äº‹ä»¶ï¼ˆä¸é˜»å¡é˜Ÿåˆ—ï¼‰
  'scene_start': { narrative: false },
  'scene_end':   { narrative: false },
  'show':        { narrative: false },
  'hide':        { narrative: false },
  'play_audio':  { narrative: false },  // æ”¯æŒ channel: sound/music/ambient
  'stop_audio':  { narrative: false },
  'story_start': { narrative: false },
  'story_end':   { narrative: false },
  'chapter_start': { narrative: false },
  'chapter_end': { narrative: false },
};

interface NarrativeQueueOptions {
  textTrack: TextTrack;
  visualTrack: VisualTrack;
  audioTrack: AudioTrack;
  resourcePool: ResourcePool;
}

class NarrativeQueue {
  private queue: SSEEvent[] = [];
  private isProcessing = false;
  private isPaused = false;
  
  private textTrack: TextTrack;
  private visualTrack: VisualTrack;
  private audioTrack: AudioTrack;
  private resourcePool: ResourcePool;
  
  private onQueueEmpty?: () => void;
  
  // å™äº‹é”ï¼šæ§åˆ¶å™äº‹äº‹ä»¶ä¹‹é—´çš„é˜»å¡
  private narrativeLock: Promise<void> = Promise.resolve();
  
  // ç”¨æˆ·é…ç½®
  private afmEnabled = true;
  private afmDelay = 500;
  private choiceTimeout = 30;  // é€‰é¡¹è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰

  constructor(options: NarrativeQueueOptions) {
    this.textTrack = options.textTrack;
    this.visualTrack = options.visualTrack;
    this.audioTrack = options.audioTrack;
    this.resourcePool = options.resourcePool;
  }

  /**
   * å…¥é˜Ÿäº‹ä»¶
   */
  enqueue(event: SSEEvent): void {
    this.queue.push(event);
    
    if (!this.isProcessing && !this.isPaused) {
      this.processNext();
    }
  }

  /**
   * å¤„ç†ä¸‹ä¸€ä¸ªäº‹ä»¶ï¼ˆé€’å½’è°ƒç”¨ï¼‰
   */
  private processNext(): void {
    if (this.queue.length === 0 || this.isPaused) {
      this.isProcessing = false;
      this.onQueueEmpty?.();
      return;
    }
    
    this.isProcessing = true;
    const event = this.queue.shift()!;
    const metadata = EVENT_REGISTRY[event.event_type];
    
    if (!metadata) {
      console.warn(`æœªçŸ¥äº‹ä»¶ç±»å‹: ${event.event_type}`);
      this.processNext();
      return;
    }
    
    if (metadata.narrative) {
      // å™äº‹äº‹ä»¶ï¼šç­‰å¾…å™äº‹é”é‡Šæ”¾åæ‰§è¡Œ
      this.narrativeLock.then(() => {
        // æ‰§è¡Œäº‹ä»¶ï¼ˆå¯èƒ½æ¶‰åŠå¤šä¸ªè½¨é“ï¼šæ–‡æœ¬+è¯­éŸ³+å›¾åƒï¼‰
        this.dispatchEvent(event);
        
        // åˆ›å»ºæ–°çš„å™äº‹é”ï¼Œç­‰å¾…ç”¨æˆ·ç‚¹å‡»/AFM
        this.narrativeLock = this.waitForNarrativeComplete(event);
        
        // å™äº‹é”é‡Šæ”¾åï¼Œç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ª
        this.narrativeLock.then(() => this.processNext());
      });
    } else {
      // éå™äº‹äº‹ä»¶ï¼šç›´æ¥æ‰§è¡Œï¼Œç«‹å³å¤„ç†ä¸‹ä¸€ä¸ª
      this.dispatchEvent(event);
      this.processNext();
    }
  }

  /**
   * åˆ†å‘äº‹ä»¶ï¼šéå†äº‹ä»¶ä¸­çš„èµ„æºï¼Œæ ¹æ®èµ„æºç±»å‹åˆ†å‘åˆ°å¯¹åº”è½¨é“
   * äº‹ä»¶ä¸éœ€è¦çŸ¥é“æœ‰å“ªäº›è½¨é“ï¼Œåªéœ€è¦å®šä¹‰æœ‰å“ªäº›èµ„æº
   */
  private dispatchEvent(event: SSEEvent): void {
    const content = event.content;
    
    // éå†èµ„æºï¼Œæ ¹æ®èµ„æºç±»å‹åˆ†å‘åˆ°å¯¹åº”è½¨é“
    // æ–‡æœ¬èµ„æº â†’ TextTrack
    if (content.text !== undefined) {
      if (content.character_name) {
        this.textTrack.showDialogue(content.character_name, content.text, content.character_color);
      } else {
        this.textTrack.showNarration(content.text);
      }
    }
    
    // é€‰é¡¹èµ„æº â†’ TextTrack
    if (content.options) {
      this.textTrack.showChoice(content.prompt, content.options);
    }
    
    // è¯­éŸ³èµ„æº â†’ AudioTrack
    if (content.voice?.url) {
      this.audioTrack.playVoice(content.voice);
    }
    
    // è§’è‰²å±•ç¤ºèµ„æº â†’ VisualTrackï¼ˆæ”¯æŒé™æ€å›¾ã€åŠ¨å›¾ã€è§†é¢‘ï¼‰
    if (content.show?.url) {
      this.visualTrack.showCharacter(content.character_id, content.show);
    }
    
    // èƒŒæ™¯èµ„æº â†’ VisualTrack
    if (content.background?.url) {
      this.visualTrack.setScene(content.background);
    }
    
    // éŸ³ä¹èµ„æº â†’ AudioTrackï¼ˆscene_start ä¸­çš„ musicï¼‰
    if (content.music?.url) {
      this.audioTrack.playMusic(content.music);
    }
    
    // ç¯å¢ƒéŸ³èµ„æº â†’ AudioTrackï¼ˆscene_start ä¸­çš„ ambientï¼‰
    if (content.ambient?.url) {
      this.audioTrack.playAmbient(content.ambient);
    }
    
    // play_audio äº‹ä»¶ï¼šæ ¹æ® channel åˆ†å‘åˆ°å¯¹åº”æ’­æ”¾å™¨
    if (content.audio?.url) {
      const channel = content.channel || 'sound';
      switch (channel) {
        case 'music':
          this.audioTrack.playMusic(content.audio);
          break;
        case 'ambient':
          this.audioTrack.playAmbient(content.audio);
          break;
        case 'sound':
        default:
          this.audioTrack.playSound(content.audio);
          break;
      }
    }
    
    // è§†é¢‘èµ„æº â†’ VisualTrack (play_videoäº‹ä»¶ï¼Œè§†è§‰è½¨é“å†…æ›¿æ¢å¼æ’­æ”¾ï¼Œä¸é˜»å¡å™äº‹é˜Ÿåˆ—)
    if (event.event_type === 'play_video' && content.video?.url) {
      this.visualTrack.playVideo(content.video.url);  // ä¸ä½¿ç”¨ awaitï¼Œä¸é˜»å¡å™äº‹é˜Ÿåˆ—
    }
    
    // æ˜¾ç¤º/éšè—å…ƒç´ 
    if (content.element && event.event_type === 'show') {
      this.visualTrack.showElement(content.layer, content.element);
    }
    if (content.element_id && event.event_type === 'hide') {
      this.visualTrack.hideElement(content.layer, content.element_id);
    }
    
    // åœºæ™¯ç»“æŸ
    if (event.event_type === 'scene_end') {
      this.visualTrack.endScene(content.transition);
    }
    
    // åœæ­¢éŸ³é¢‘
    if (event.event_type === 'stop_audio') {
      this.audioTrack.stop(content.channel, content.fade_out);
    }
  }


  /**
   * ç­‰å¾…å™äº‹äº‹ä»¶å®Œæˆï¼ˆAFM æˆ–ç”¨æˆ·ç‚¹å‡»ï¼‰
   */
  private async waitForNarrativeComplete(event: SSEEvent): Promise<void> {
    if (event.event_type === 'choice') {
      // é€‰é¡¹ï¼šç­‰å¾…ç”¨æˆ·é€‰æ‹©ï¼ˆå¸¦è¶…æ—¶ï¼‰
      const defaultOptionId = event.content.options[0]?.option_id;
      const selectedOptionId = await this.textTrack.waitForChoice(this.choiceTimeout, defaultOptionId);
      
      // è·å–é€‰ä¸­é€‰é¡¹çš„ next_sequence_idï¼ˆåˆ†æ”¯è·³è½¬ï¼‰
      const selectedOption = event.content.options.find(
        o => o.option_id === selectedOptionId
      );
      
      if (selectedOption?.next_sequence_id) {
        // é€šçŸ¥ DataManager å‡†å¤‡æ¥æ”¶æ–°åˆ†æ”¯çš„äº‹ä»¶
        // SSE æµä¼šæ ¹æ® choice è‡ªåŠ¨æ¨é€å¯¹åº”åˆ†æ”¯çš„äº‹ä»¶
        console.log(`åˆ†æ”¯è·³è½¬: ${selectedOptionId} â†’ ${selectedOption.next_sequence_id}`);
        
        // ä¿å­˜ç”¨æˆ·é€‰æ‹©åˆ°æœåŠ¡ç«¯
        await this.saveUserChoice(event.content.story_id, selectedOptionId);
      }
    } else {
      // å¯¹è¯/æ—ç™½ï¼šAFM æˆ–ç”¨æˆ·ç‚¹å‡»
      await this.waitForAdvance(event);
    }
    
    // äº‹ä»¶ç»“æŸæ¸…ç†
    this.cleanupAfterEvent(event);
  }
  
  /**
   * ä¿å­˜ç”¨æˆ·é€‰æ‹©
   */
  private async saveUserChoice(storyId: string, choiceId: string): Promise<void> {
    try {
      await fetch(`/api/v1/story/${storyId}/choice`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ option_id: optionId })
      });
    } catch (error) {
      console.error('ä¿å­˜ç”¨æˆ·é€‰æ‹©å¤±è´¥:', error);
    }
  }

  /**
   * ç­‰å¾…æ¨è¿›ï¼ˆAFM æˆ–ç”¨æˆ·ç‚¹å‡»ï¼‰
   */
  private async waitForAdvance(event: SSEEvent): Promise<void> {
    const hasVoice = !!event.content?.voice?.url;
    
    if (this.afmEnabled && hasVoice) {
      // AFM æ¨¡å¼ï¼šç­‰å¾…è¯­éŸ³æ’­å®Œ + å»¶è¿Ÿ
      await this.audioTrack.waitForVoiceComplete();
      await this.sleep(this.afmDelay);
    } else {
      // æ‰‹åŠ¨æ¨¡å¼ï¼šç­‰å¾…ç”¨æˆ·ç‚¹å‡»
      await this.textTrack.waitForClick();
    }
  }

  /**
   * äº‹ä»¶ç»“æŸåæ¸…ç†
   */
  private cleanupAfterEvent(event: SSEEvent): void {
    // åœæ­¢è¯­éŸ³
    this.audioTrack.stopVoice();
    
    // éšè—è§’è‰²å›¾åƒï¼ˆå¦‚æœè®¾ç½®äº† auto_hideï¼‰
    if (event.event_type === 'dialogue' && event.content?.auto_hide !== false) {
      this.visualTrack.hideCharacter(event.content.character_id);
    }
    
    // æ¸…é™¤æ–‡æœ¬
    this.textTrack.clear();
  }

  /**
   * æš‚åœé˜Ÿåˆ—
   */
  pause(): void {
    this.isPaused = true;
  }

  /**
   * æ¢å¤é˜Ÿåˆ—
   */
  resume(): void {
    this.isPaused = false;
    if (!this.isProcessing && this.queue.length > 0) {
      this.process();
    }
  }

  /**
   * è®¾ç½®é˜Ÿåˆ—ç©ºå›è°ƒ
   */
  setOnQueueEmpty(callback: () => void): void {
    this.onQueueEmpty = callback;
  }

  /**
   * è®¾ç½® AFM é…ç½®
   */
  setAFM(enabled: boolean, delay: number = 500): void {
    this.afmEnabled = enabled;
    this.afmDelay = delay;
  }

  /**
   * è®¾ç½®èœå•è¶…æ—¶æ—¶é—´
   */
  setMenuTimeout(timeout: number): void {
    this.choiceTimeout = timeout;
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

---

### 0.3 ProgressTracker - è¿›åº¦åŒæ­¥

**èŒè´£**ï¼šç®¡ç†ç”¨æˆ·æ’­æ”¾è¿›åº¦ï¼Œé‡‡ç”¨å»¶è¿ŸåŒæ­¥ç­–ç•¥ä¼˜åŒ–æ€§èƒ½

**è®¾è®¡åŸåˆ™**ï¼š
- âŒ **ä¸æ˜¯æ¯æ¬¡ç‚¹å‡»éƒ½åŒæ­¥**ï¼šé¿å…é«˜é¢‘å†™å…¥å¸¦æ¥çš„æ€§èƒ½é—®é¢˜
- âœ… **å…³é”®ç‚¹åŒæ­¥**ï¼šä»…åœ¨ `choice`ã€`scene_start`ã€`chapter_start`ã€`story_end` æ—¶åŒæ­¥
- âœ… **é€€å‡ºæ—¶åŒæ­¥**ï¼šç”¨æˆ·å…³é—­é¡µé¢æ—¶é€šè¿‡ `sendBeacon` ä¿å­˜è¿›åº¦

**æ€§èƒ½å¯¹æ¯”**ï¼š

| ç­–ç•¥ | æ¯ç§’å†™å…¥é‡ï¼ˆ1000å¹¶å‘ç”¨æˆ·ï¼‰ |
|------|--------------------------|
| æ¯æ¬¡ç‚¹å‡»éƒ½å†™ | ~200 æ¬¡/ç§’ |
| å…³é”®ç‚¹ + é€€å‡ºæ—¶åŒæ­¥ | ~10-20 æ¬¡/ç§’ |

```typescript
class ProgressTracker {
  private storyId: string;
  private versionId: string;
  private lastSyncedSequenceId: string = '';
  private currentSequenceId: string = '';
  
  // å…³é”®äº‹ä»¶ç±»å‹ï¼ˆè§¦å‘åŒæ­¥ï¼‰
  private readonly SYNC_EVENTS = new Set([
    'choice', 'scene_start', 'chapter_start', 'story_end'
  ]);
  
  constructor(storyId: string, versionId: string) {
    this.storyId = storyId;
    this.versionId = versionId;
    
    // æ³¨å†Œé¡µé¢å¸è½½äº‹ä»¶
    window.addEventListener('beforeunload', () => this.onBeforeUnload());
    window.addEventListener('pagehide', () => this.onBeforeUnload());
  }
  
  /**
   * äº‹ä»¶æ’­æ”¾å®Œæˆæ—¶è°ƒç”¨
   */
  onEventPlayed(event: SSEEvent): void {
    this.currentSequenceId = event.sequence_id;
    
    // å…³é”®ç‚¹åŒæ­¥
    if (this.SYNC_EVENTS.has(event.event_type)) {
      this.syncToServer();
    }
  }
  
  /**
   * åŒæ­¥è¿›åº¦åˆ°æœåŠ¡å™¨
   */
  private async syncToServer(): Promise<void> {
    if (this.currentSequenceId === this.lastSyncedSequenceId) return;
    
    try {
      await fetch(`/api/v1/story/${this.storyId}/progress`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          version_id: this.versionId,
          current_sequence_id: this.currentSequenceId
        })
      });
      
      this.lastSyncedSequenceId = this.currentSequenceId;
    } catch (error) {
      console.warn('Progress sync failed:', error);
      // å¤±è´¥ä¸é˜»å¡ï¼Œä¸‹æ¬¡å…³é”®ç‚¹ä¼šé‡è¯•
    }
  }
  
  /**
   * é¡µé¢å¸è½½æ—¶åŒæ­¥ï¼ˆä½¿ç”¨ sendBeacon ç¡®ä¿å¯é å‘é€ï¼‰
   */
  private onBeforeUnload(): void {
    if (this.currentSequenceId === this.lastSyncedSequenceId) return;
    
    // sendBeacon åœ¨é¡µé¢å¸è½½æ—¶ä»èƒ½å¯é å‘é€
    const success = navigator.sendBeacon(
      `/api/v1/story/${this.storyId}/progress`,
      JSON.stringify({
        version_id: this.versionId,
        current_sequence_id: this.currentSequenceId
      })
    );
    
    if (success) {
      this.lastSyncedSequenceId = this.currentSequenceId;
    }
  }
  
  /**
   * æ›´æ–°å½“å‰ç‰ˆæœ¬ï¼ˆç”¨æˆ·åšé€‰æ‹©ååˆ‡æ¢åˆ°æ–°ç‰ˆæœ¬ï¼‰
   */
  setVersion(versionId: string): void {
    this.versionId = versionId;
  }
  
  /**
   * æ¸…ç†èµ„æº
   */
  destroy(): void {
    window.removeEventListener('beforeunload', () => this.onBeforeUnload());
    window.removeEventListener('pagehide', () => this.onBeforeUnload());
  }
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```typescript
// åˆå§‹åŒ–
const progressTracker = new ProgressTracker(storyId, versionId);

// NarrativeQueue æ’­æ”¾äº‹ä»¶åè°ƒç”¨
narrativeQueue.onEventComplete = (event) => {
  progressTracker.onEventPlayed(event);
};

// ç”¨æˆ·åšé€‰æ‹©åï¼Œåˆ‡æ¢åˆ°æ–°ç‰ˆæœ¬
progressTracker.setVersion(newVersionId);
```

> **æ³¨æ„**ï¼šé‡‡ç”¨å»¶è¿ŸåŒæ­¥ç­–ç•¥åï¼Œç”¨æˆ·åœ¨ä¸¤ä¸ªå…³é”®ç‚¹ä¹‹é—´æ–­å¼€å¯èƒ½ä¸¢å¤±å°‘é‡è¿›åº¦ï¼ˆæœ€å¤šå›é€€åˆ°ä¸Šä¸€ä¸ªåœºæ™¯/ç« èŠ‚èµ·ç‚¹ï¼‰ã€‚å¯¹äºäº’åŠ¨å™äº‹åœºæ™¯ï¼Œè¿™æ˜¯å¯æ¥å—çš„ä½“éªŒã€‚

---

### 1. ResourcePool - èµ„æºæ± 

**èŒè´£**ï¼šå¼‚æ­¥ä¸‹è½½å’Œç¼“å­˜æ‰€æœ‰åª’ä½“èµ„æºï¼ˆå›¾åƒã€è§†é¢‘ã€éŸ³é¢‘ï¼‰

**ç‰¹æ€§**ï¼š
- å¹¶å‘æ§åˆ¶ï¼šæœ€å¤šåŒæ—¶ä¸‹è½½ N ä¸ªèµ„æºï¼ˆå¯é…ç½®ï¼Œé»˜è®¤ 6ï¼‰
- è‡ªåŠ¨é‡è¯•ï¼šä¸‹è½½å¤±è´¥è‡ªåŠ¨é‡è¯•ï¼ˆæœ€å¤š 3 æ¬¡ï¼‰
- å®¹é”™å¤„ç†ï¼šä¸‹è½½å¤±è´¥ä¸é˜»å¡å™äº‹ï¼Œè¿”å› null

```typescript
type ResourceType = 'image' | 'video' | 'audio';

interface DownloadTask {
  url: string;
  type: ResourceType;
  resolve: (value: any) => void;
  reject: (error: any) => void;
}

class ResourcePool {
  private loadedResources: Map<string, any> = new Map();
  private loadingPromises: Map<string, Promise<any>> = new Map();
  
  // å¹¶å‘æ§åˆ¶
  private maxConcurrent: number;
  private activeCount = 0;
  private queue: DownloadTask[] = [];
  
  // é‡è¯•é…ç½®
  private maxRetries = 3;

  constructor(options: { maxConcurrent?: number } = {}) {
    this.maxConcurrent = options.maxConcurrent ?? 6;
  }

  /**
   * ä¸‹è½½èµ„æºï¼ˆè‡ªåŠ¨æ’é˜Ÿã€é‡è¯•ã€å®¹é”™ï¼‰
   */
  async download(url: string, type: ResourceType): Promise<any> {
    // å·²åŠ è½½ï¼Œç›´æ¥è¿”å›
    if (this.loadedResources.has(url)) {
      return this.loadedResources.get(url);
    }

    // æ­£åœ¨åŠ è½½ï¼Œå¤ç”¨ Promise
    if (this.loadingPromises.has(url)) {
      return this.loadingPromises.get(url)!;
    }

    // åŠ å…¥ä¸‹è½½é˜Ÿåˆ—
    const promise = new Promise<any>((resolve, reject) => {
      this.queue.push({ url, type, resolve, reject });
    });
    
    this.loadingPromises.set(url, promise);
    this.processQueue();
    
    return promise;
  }

  /**
   * å¤„ç†ä¸‹è½½é˜Ÿåˆ—
   */
  private processQueue(): void {
    while (this.activeCount < this.maxConcurrent && this.queue.length > 0) {
      const task = this.queue.shift()!;
      this.activeCount++;
      
      this.downloadWithRetry(task.url, task.type)
        .then(resource => {
          this.loadedResources.set(task.url, resource);
          task.resolve(resource);
        })
        .catch(error => {
          console.warn(`èµ„æºä¸‹è½½å¤±è´¥ï¼ˆå·²é‡è¯•${this.maxRetries}æ¬¡ï¼‰: ${task.url}`);
          task.resolve(null);  // å¤±è´¥è¿”å› nullï¼Œä¸é˜»å¡å™äº‹
        })
        .finally(() => {
          this.loadingPromises.delete(task.url);
          this.activeCount--;
          this.processQueue();
        });
    }
  }

  /**
   * å¸¦é‡è¯•çš„ä¸‹è½½
   */
  private async downloadWithRetry(url: string, type: ResourceType): Promise<any> {
    let lastError: Error | null = null;
    
    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      try {
        return await this.doDownload(url, type);
      } catch (error) {
        lastError = error as Error;
        console.warn(`èµ„æºä¸‹è½½å¤±è´¥ï¼ˆç¬¬${attempt}æ¬¡ï¼‰: ${url}`);
        
        if (attempt < this.maxRetries) {
          // æŒ‡æ•°é€€é¿ï¼š1s, 2s, 4s...
          await this.sleep(1000 * Math.pow(2, attempt - 1));
        }
      }
    }
    
    throw lastError;
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  private async doDownload(url: string, type: ResourceType): Promise<any> {
    switch (type) {
      case 'image':
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = () => reject(new Error(`å›¾åƒåŠ è½½å¤±è´¥: ${url}`));
          img.src = url;
        });

      case 'video':
        return new Promise((resolve, reject) => {
          const video = document.createElement('video');
          video.preload = 'auto';
          video.muted = true;
          video.playsInline = true;
          video.crossOrigin = 'anonymous';
          video.addEventListener('canplaythrough', () => resolve(video), { once: true });
          video.addEventListener('error', () => reject(new Error(`è§†é¢‘åŠ è½½å¤±è´¥: ${url}`)), { once: true });
          video.src = url;
        });

      case 'audio':
        return new Promise((resolve, reject) => {
          const audio = new Audio();
          audio.preload = 'auto';
          audio.addEventListener('canplaythrough', () => resolve(audio), { once: true });
          audio.addEventListener('error', () => reject(new Error(`éŸ³é¢‘åŠ è½½å¤±è´¥: ${url}`)), { once: true });
          audio.src = url;
        });

      default:
        throw new Error(`æœªçŸ¥èµ„æºç±»å‹: ${type}`);
    }
  }

  /**
   * ç­‰å¾…èµ„æºå°±ç»ª
   * è¿”å›èµ„æºæˆ– nullï¼ˆå¦‚æœä¸‹è½½å¤±è´¥ï¼‰
   */
  async waitFor(url: string): Promise<any> {
    if (this.loadedResources.has(url)) {
      return this.loadedResources.get(url);
    }
    if (this.loadingPromises.has(url)) {
      return this.loadingPromises.get(url);
    }
    // èµ„æºæœªåœ¨é˜Ÿåˆ—ä¸­ï¼Œè¿”å› null
    console.warn(`èµ„æºæœªé¢„åŠ è½½: ${url}`);
    return null;
  }
}
```

---

### 2. NarrativeEventParser - å™äº‹äº‹ä»¶è§£æå™¨

**èŒè´£**ï¼šå°†å™äº‹äº‹ä»¶è§£æä¸ºåŸå­æ“ä½œ + èµ„æºåˆ—è¡¨ + æ¸…ç†è§„åˆ™

```typescript
interface ParsedEvent {
  operations: AtomicOperation[];
  resources: Array<{ url: string; type: 'image' | 'audio'; key: string }>;
  cleanup?: {
    on_complete: AtomicOperation[];
  };
}

class NarrativeEventParser {
  parse(event: NarrativeEvent): ParsedEvent {
    switch (event.event_type) {
      case 'story_start':
        return this.parseStoryStart(event);
      case 'story_end':
        return this.parseStoryEnd(event);
      case 'chapter_start':
        return this.parseChapterStart(event);
      case 'chapter_end':
        return this.parseChapterEnd(event);
      case 'scene_start':
        return this.parseSceneStart(event);
      case 'scene_end':
        return this.parseSceneEnd(event);
      case 'play_audio':
        return this.parsePlaySound(event);
      case 'narration':
        return this.parseNarration(event);
      case 'dialogue':
        return this.parseDialogue(event);
      case 'choice':
        return this.parseMenu(event);
      default:
        throw new Error(`æœªçŸ¥äº‹ä»¶ç±»å‹: ${event.event_type}`);
    }
  }

  /**
   * è§£æ story_start äº‹ä»¶
   */
  private parseStoryStart(event: StoryStartEvent): ParsedEvent {
    // æ˜¾ç¤ºæ•…äº‹æ ‡é¢˜ç­‰ä¿¡æ¯
    return {
      operations: [
        { type: 'show_story_title', title: event.content.title, theme: event.content.theme }
      ],
      resources: []
    };
  }

  /**
   * è§£æ story_end äº‹ä»¶
   */
  private parseStoryEnd(event: StoryEndEvent): ParsedEvent {
    // æ˜¾ç¤ºæ•…äº‹ç»“æŸä¿¡æ¯
    return {
      operations: [
        { type: 'show_ending', message: event.content.message }
      ],
      resources: []
    };
  }

  /**
   * è§£æ chapter_start äº‹ä»¶
   */
  private parseChapterStart(event: ChapterStartEvent): ParsedEvent {
    // æ˜¾ç¤ºç« èŠ‚æ ‡é¢˜
    return {
      operations: [
        { type: 'show_chapter_title', title: event.content.title, chapter_number: event.content.chapter_number }
      ],
      resources: []
    };
  }

  /**
   * è§£æ chapter_end äº‹ä»¶
   */
  private parseChapterEnd(event: ChapterEndEvent): ParsedEvent {
    // æ˜¾ç¤ºç« èŠ‚ç»“æŸä¿¡æ¯
    return {
      operations: [
        { type: 'show_chapter_end', message: event.content.message }
      ],
      resources: []
    };
  }

  /**
   * è§£æ scene_start äº‹ä»¶
   */
  private parseSceneStart(event: SceneStartEvent): ParsedEvent {
    const operations = [];
    const resources = [];

    // æ¸…ç†æ“ä½œ
    operations.push({ type: 'stop', channel: 'music' });
    operations.push({ type: 'stop', channel: 'sound', sound_type: 'ambient' });
    operations.push({ type: 'hide_all' });

    // æ˜¾ç¤ºèƒŒæ™¯
    operations.push({
      type: 'show',
      element_id: `bg_${event.content.scene_id}`,
      element_type: 'background',
      url: event.content.background.url,
      key: `bg_${event.content.scene_id}`
    });
    resources.push({
      url: event.content.background.url,
      type: 'image',
      key: `bg_${event.content.scene_id}`
    });

    // è·å–è½¬åœºæ·¡å…¥æ—¶é—´
    const fadeInDuration = event.content.transition?.duration;

    // æ’­æ”¾éŸ³ä¹
    if (event.content.music) {
      operations.push({
        type: 'play',
        channel: 'music',
        url: event.content.music.url,
        key: `music_${event.content.scene_id}`
      });
      resources.push({
        url: event.content.music.url,
        type: 'audio',
        key: `music_${event.content.scene_id}`
      });
    }

    // æ’­æ”¾ç¯å¢ƒéŸ³
    if (event.content.ambient) {
      operations.push({
        type: 'play',
        channel: 'ambient',
        url: event.content.ambient.url,
        key: `ambient_${event.content.scene_id}`
      });
      resources.push({
        url: event.content.ambient.url,
        type: 'audio',
        key: `ambient_${event.content.scene_id}`
      });
    }

    return { operations, resources };
  }

  /**
   * è§£æ dialogue äº‹ä»¶
   * 
   * æ”¯æŒè§’è‰²å›¾åƒç±»å‹ï¼š
   * - é™æ€å›¾åƒï¼šPNG/JPG/WebP
   * - åŠ¨æ€å›¾åƒï¼šGIF/APNG/WebPåŠ¨ç”»
   * - è§†é¢‘è§’è‰²ï¼šé€æ˜WebMï¼ˆé€šè¿‡URLæ‰©å±•åè‡ªåŠ¨åˆ¤æ–­ï¼‰
   */
  private parseDialogue(event: DialogueEvent): ParsedEvent {
    const operations = [];
    const resources = [];

    // æ˜¾ç¤ºè§’è‰²ï¼ˆæ”¯æŒé™æ€å›¾ã€åŠ¨å›¾ã€è§†é¢‘ï¼‰
    if (event.content.show) {
      // é€šè¿‡URLæ‰©å±•ååˆ¤æ–­æ˜¯å¦ä¸ºè§†é¢‘
      const isVideo = this.isVideoUrl(event.content.show.url);
      
      operations.push({
        type: 'show',
        element_id: event.content.character_id,
        element_type: 'character',
        url: event.content.show.url,
        position: event.content.show.position,
        // è§†é¢‘ç‰¹æœ‰å±æ€§ï¼ˆä»…å½“æœ‰video_configæ—¶ä½¿ç”¨ï¼‰
        ...(event.content.show.video_config && {
          loop: event.content.show.video_config.loop ?? true,
          muted: event.content.show.video_config.muted ?? true,
          autoplay: event.content.show.video_config.autoplay ?? true,
        }),
        key: `char_${event.content.character_id}`
      });
      
      // æ ¹æ®URLæ‰©å±•ååˆ¤æ–­èµ„æºç±»å‹
      resources.push({
        url: event.content.show.url,
        type: isVideo ? 'video' : 'image',
        key: `char_${event.content.character_id}`
      });
    }

    // æ’­æ”¾é…éŸ³
    if (event.content.voice) {
      operations.push({
        type: 'play',
        channel: 'voice',
        url: event.content.voice.url,
        key: `voice_${event.sequence_id}`
      });
      resources.push({
        url: event.content.voice.url,
        type: 'audio',
        key: `voice_${event.sequence_id}`
      });
    }

    // æ˜¾ç¤ºæ–‡å­—
    operations.push({
      type: 'say',
      role: event.content.character_name,
      content: event.content.text,
      roleColor: event.content.character_color,
      voice_duration: event.content.voice?.duration
      // AFM å‚æ•°ç”±å…¨å±€è®¾ç½®æä¾›ï¼Œè§ executeAtomicOperation
    });

    // æ¸…ç†è§„åˆ™
    const cleanup = {
      on_complete: [
        { type: 'stop', channel: 'voice' },
        ...(event.content.auto_hide !== false && event.content.show
          ? [{ type: 'hide', element_id: event.content.character_id }]
          : [])
      ]
    };

    return { operations, resources, cleanup };
  }

  /**
   * é€šè¿‡URLæ‰©å±•ååˆ¤æ–­æ˜¯å¦ä¸ºè§†é¢‘
   */
  private isVideoUrl(url: string): boolean {
    const videoExtensions = ['.webm', '.mp4', '.ogv'];
    const urlLower = url.toLowerCase();
    return videoExtensions.some(ext => urlLower.includes(ext));
  }

  /**
   * è§£æ narration äº‹ä»¶
   */
  private parseNarration(event: NarrationEvent): ParsedEvent {
    const operations = [];
    const resources = [];

    // æ’­æ”¾é…éŸ³
    if (event.content.voice) {
      operations.push({
        type: 'play',
        channel: 'voice',
        url: event.content.voice.url,
        key: `voice_${event.sequence_id}`
      });
      resources.push({
        url: event.content.voice.url,
        type: 'audio',
        key: `voice_${event.sequence_id}`
      });
    }

    // æ˜¾ç¤ºæ–‡å­—
    operations.push({
      type: 'say',
      role: undefined,
      content: event.content.text,
      voice_duration: event.content.voice?.duration
      // AFM å‚æ•°ç”±å…¨å±€è®¾ç½®æä¾›
    });

    // æ¸…ç†è§„åˆ™
    const cleanup = {
      on_complete: [{ type: 'stop', channel: 'voice' }]
    };

    return { operations, resources, cleanup };
  }

  /**
   * è§£æ play_audio äº‹ä»¶
   */
  private parsePlaySound(event: PlaySoundEvent): ParsedEvent {
    const channel = event.content.channel || 'sound';
    
    const operations = [{
      type: 'play',
      channel: channel,
      url: event.content.url,
      key: `${channel}_${event.sequence_id}`
    }];

    const resources = [{
      url: event.content.url,
      type: 'audio',
      key: `${channel}_${event.sequence_id}`
    }];

    // sound é€šé“æ’­æ”¾å®Œè‡ªåŠ¨åœæ­¢ï¼Œmusic/ambient å¾ªç¯æ’­æ”¾ä¸æ¸…ç†
    const cleanup = channel === 'sound'
      ? undefined  // sound æ’­æ”¾å®Œè‡ªåŠ¨ä»æ± ä¸­ç§»é™¤ï¼Œæ— éœ€æ¸…ç†
      : undefined;

    return { operations, resources, cleanup };
  }
}
```

---

### 3. TextTrack - æ–‡æœ¬è½¨é“

**èŒè´£**ï¼šå¤„ç†æ–‡æœ¬æ¸²æŸ“ï¼ˆå¯¹è¯/æ—ç™½/èœå•ï¼‰ï¼Œæä¾›æ‰“å­—æœºæ•ˆæœå’Œç”¨æˆ·äº¤äº’

**é˜»å¡è§„åˆ™**ï¼šæ–‡æœ¬æ›¿æ¢å¼æ’­æ”¾ï¼ˆæ–°æ–‡æœ¬æ›¿æ¢æ—§æ–‡æœ¬ï¼ŒåŒä¸€æ—¶åˆ»åªæ˜¾ç¤ºä¸€æ®µï¼‰

```typescript
interface TextContent {
  speaker?: string;
  speakerColor?: string;
  text: string;
}

interface MenuChoice {
  option_id: string;
  text: string;
}

class TextTrack {
  private container: HTMLElement;
  private speakerElement: HTMLElement;
  private textElement: HTMLElement;
  private optionsContainer: HTMLElement;
  
  // é…ç½®
  private textSpeed = 50;  // æ¯å­—ç¬¦æ¯«ç§’æ•°
  
  // äº¤äº’ Promise
  private clickResolver?: () => void;
  private choiceResolver?: (choiceId: string) => void;
  
  // ä¸­æ–­æ§åˆ¶
  private currentAbortController: AbortController | null = null;

  constructor(container: HTMLElement) {
    this.container = container;
    this.speakerElement = container.querySelector('.speaker')!;
    this.textElement = container.querySelector('.text')!;
    this.optionsContainer = container.querySelector('.options')!;
    
    // ç»‘å®šç‚¹å‡»äº‹ä»¶
    this.container.addEventListener('click', () => this.onClick());
  }

  /**
   * æ˜¾ç¤ºå¯¹è¯æ–‡æœ¬
   */
  async showDialogue(character: string, text: string, color?: string): Promise<void> {
    this.speakerElement.textContent = character;
    if (color) {
      this.speakerElement.style.color = color;
    }
    await this.typeText(text);
  }

  /**
   * æ˜¾ç¤ºæ—ç™½æ–‡æœ¬
   */
  async showNarration(text: string): Promise<void> {
    this.speakerElement.textContent = '';
    await this.typeText(text);
  }

  /**
   * æ˜¾ç¤ºé€‰é¡¹
   */
  showChoice(prompt: string, options: ChoiceOption[]): void {
    this.textElement.textContent = prompt;
    this.optionsContainer.innerHTML = '';
    
    options.forEach(option => {
      const btn = document.createElement('button');
      btn.textContent = option.text;
      btn.className = 'option-button';
      btn.onclick = () => this.onOptionSelected(option.option_id);
      this.optionsContainer.appendChild(btn);
    });
    
    this.optionsContainer.style.display = 'block';
  }

  /**
   * ç­‰å¾…ç”¨æˆ·é€‰æ‹©ï¼ˆèœå•ï¼‰
   * 
   * @param timeout è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œæ¥è‡ªç”¨æˆ·è®¾ç½®
   * @param defaultOptionId é»˜è®¤é€‰é¡¹IDï¼ˆé€šå¸¸æ˜¯ options[0].option_idï¼‰
   */
  waitForChoice(timeout: number, defaultOptionId: string): Promise<string> {
    return new Promise(resolve => {
      this.choiceResolver = resolve;
      
      // è®¾ç½®è¶…æ—¶è‡ªåŠ¨é€‰æ‹©
      setTimeout(() => {
        if (this.choiceResolver) {
          console.log(`â±ï¸ èœå•è¶…æ—¶ï¼Œè‡ªåŠ¨é€‰æ‹©é»˜è®¤é€‰é¡¹: ${defaultChoiceId}`);
          this.choiceResolver(defaultChoiceId);
          this.choiceResolver = undefined;
        }
      }, timeout * 1000);
    });
  }

  /**
   * ç­‰å¾…ç”¨æˆ·ç‚¹å‡»
   */
  waitForClick(): Promise<void> {
    return new Promise(resolve => {
      this.clickResolver = resolve;
    });
  }

  /**
   * æ¸…é™¤æ–‡æœ¬
   */
  clear(): void {
    this.speakerElement.textContent = '';
    this.textElement.textContent = '';
    this.optionsContainer.innerHTML = '';
    this.optionsContainer.style.display = 'none';
  }

  /**
   * è·³è¿‡å½“å‰æ‰“å­—æ•ˆæœ
   */
  skip(): void {
    if (this.currentAbortController) {
      this.currentAbortController.abort();
    }
  }

  /**
   * è®¾ç½®æ–‡å­—é€Ÿåº¦
   */
  setTextSpeed(msPerChar: number): void {
    this.textSpeed = msPerChar;
  }

  /**
   * æ‰“å­—æœºæ•ˆæœ
   */
  private async typeText(text: string): Promise<void> {
    this.textElement.textContent = '';
    this.currentAbortController = new AbortController();
    const signal = this.currentAbortController.signal;
    
    for (let i = 0; i < text.length; i++) {
      if (signal.aborted) {
        // è¢«è·³è¿‡ï¼Œç«‹å³æ˜¾ç¤ºå…¨éƒ¨æ–‡æœ¬
        this.textElement.textContent = text;
        break;
      }
      
      this.textElement.textContent += text[i];
      await this.sleep(this.textSpeed);
    }
    
    this.currentAbortController = null;
  }

  /**
   * ç‚¹å‡»äº‹ä»¶å¤„ç†
   */
  private onClick(): void {
    if (this.currentAbortController) {
      // æ­£åœ¨æ‰“å­—ï¼Œè·³è¿‡
      this.skip();
    } else if (this.clickResolver) {
      // ç­‰å¾…ç‚¹å‡»ï¼Œè§¦å‘
      this.clickResolver();
      this.clickResolver = undefined;
    }
  }

  /**
   * é€‰é¡¹é€‰æ‹©äº‹ä»¶å¤„ç†
   */
  private onChoiceSelected(choiceId: string): void {
    if (this.choiceResolver) {
      this.choiceResolver(choiceId);
      this.choiceResolver = undefined;
    }
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

---

### 4. VisualTrack - è§†è§‰è½¨é“

**èŒè´£**ï¼šå¤„ç†è§†è§‰å…ƒç´ ï¼ˆåœºæ™¯ã€è§’è‰²å›¾åƒã€è§†é¢‘ï¼‰

**é˜»å¡è§„åˆ™**ï¼š
| èµ„æºç±»å‹ | é˜»å¡è¡Œä¸º |
|---------|---------|
| åœºæ™¯ | æ›¿æ¢å¼ |
| å›¾åƒ | å›¾å±‚å åŠ ï¼Œä¸é˜»å¡ |
| è§†é¢‘ | é˜»å¡ç›´åˆ°æ’­æ”¾å®Œæˆ |

```typescript
interface ImageConfig {
  url: string;
  position?: 'left' | 'center' | 'right';
  expression?: string;
  // è§†é¢‘è§’è‰²é…ç½®ï¼ˆå¯é€‰ï¼Œä»…å½“è§’è‰²ä¸ºè§†é¢‘æ—¶æä¾›ï¼‰
  video_config?: {
    loop?: boolean;      // æ˜¯å¦å¾ªç¯æ’­æ”¾ï¼Œé»˜è®¤ true
    muted?: boolean;     // æ˜¯å¦é™éŸ³ï¼Œé»˜è®¤ true
    autoplay?: boolean;  // æ˜¯å¦è‡ªåŠ¨æ’­æ”¾ï¼Œé»˜è®¤ true
  };
}

class VisualTrack {
  private resourcePool: ResourcePool;
  private layerManager: LayerManager;
  
  // å½“å‰æ˜¾ç¤ºçš„è§’è‰²å›¾åƒï¼ˆç”¨äºè‡ªåŠ¨éšè—ï¼‰
  private characterImages: Map<string, string> = new Map();

  constructor(resourcePool: ResourcePool, layerManager: LayerManager) {
    this.resourcePool = resourcePool;
    this.layerManager = layerManager;
  }

  /**
   * è®¾ç½®åœºæ™¯èƒŒæ™¯ï¼ˆæ›¿æ¢å¼ï¼‰
   */
  async setScene(background: { url: string; transition?: any }): Promise<void> {
    console.log('ğŸ¬ è®¾ç½®åœºæ™¯');
    
    // æ¸…ç†æ—§åœºæ™¯
    this.layerManager.hideAll();
    this.characterImages.clear();
    
    // ç­‰å¾…èƒŒæ™¯èµ„æº
    const bg = await this.resourcePool.waitFor(background.url);
    if (!bg) {
      console.warn('èƒŒæ™¯èµ„æºæœªåŠ è½½');
      return;
    }
    
    // æ˜¾ç¤ºæ–°èƒŒæ™¯
    await this.layerManager.showElement('background', bg, {
      layer: 'background',
      transition: background.transition
    });
  }

  /**
   * ç»“æŸåœºæ™¯
   * @param transition è½¬åœºé…ç½®ï¼ˆtype: fade_out, duration: ç§’ï¼‰
   */
  async endScene(transition?: { type: string; duration: number }): Promise<void> {
    console.log('ğŸ¬ ç»“æŸåœºæ™¯');
    
    // ä½¿ç”¨ hideElement éšè—èƒŒæ™¯ï¼Œæ”¯æŒå¯é…ç½®çš„è½¬åœºæ—¶é•¿
    await this.layerManager.hideElement('background', transition);
  }

  /**
   * æ˜¾ç¤ºè§’è‰²å›¾åƒï¼ˆå›¾å±‚å åŠ ï¼Œä¸é˜»å¡ï¼‰
   */
  async showCharacter(characterId: string, image: ImageConfig): Promise<void> {
    console.log(`ğŸ­ æ˜¾ç¤ºè§’è‰²: ${characterId}`);
    
    const elementId = `${characterId}_${image.expression || 'default'}`;
    
    const resource = await this.resourcePool.waitFor(image.url);
    if (!resource) {
      console.warn(`è§’è‰²å›¾åƒæœªåŠ è½½: ${characterId}`);
      return;
    }
    
    // è®°å½•å½“å‰è§’è‰²çš„å›¾åƒ
    this.characterImages.set(characterId, elementId);
    
    await this.layerManager.showElement(elementId, resource, {
      layer: 'characters',
      position: image.position || 'center',
      // å¦‚æœæœ‰video_configï¼Œä¼ é€’è§†é¢‘é…ç½®
      ...(image.video_config && {
        loop: image.video_config.loop ?? true,
        muted: image.video_config.muted ?? true,
        autoplay: image.video_config.autoplay ?? true
      })
    });
  }

  /**
   * éšè—è§’è‰²å›¾åƒ
   */
  async hideCharacter(characterId: string): Promise<void> {
    const elementId = this.characterImages.get(characterId);
    if (elementId) {
      await this.layerManager.hideElement(elementId);
      this.characterImages.delete(characterId);
    }
  }

  /**
   * æ˜¾ç¤ºé€šç”¨å…ƒç´ 
   */
  async showElement(layer: string, element: any): Promise<void> {
    const resource = await this.resourcePool.waitFor(element.url);
    if (!resource) return;
    
    await this.layerManager.showElement(element.id, resource, {
      layer,
      position: element.position
    });
  }

  /**
   * éšè—å…ƒç´ 
   */
  async hideElement(layer: string, elementId: string): Promise<void> {
    await this.layerManager.hideElement(elementId);
  }

  /**
   * æ’­æ”¾è§†é¢‘ï¼ˆé˜»å¡ç›´åˆ°å®Œæˆï¼‰
   */
  async playVideo(url: string): Promise<void> {
    console.log('ğŸ¬ æ’­æ”¾è§†é¢‘');
    
    const video = await this.resourcePool.waitFor(url);
    if (!video) {
      console.warn('è§†é¢‘èµ„æºæœªåŠ è½½');
      return;
    }
    
    // æ˜¾ç¤ºè§†é¢‘
    await this.layerManager.showElement('video-player', video, {
      layer: 'video',
      mediaType: 'video'
    });
    
    // ç­‰å¾…æ’­æ”¾å®Œæˆ
    await new Promise<void>(resolve => {
      video.play();
      video.addEventListener('ended', () => {
        this.layerManager.hideElement('video-player');
        resolve();
      }, { once: true });
    });
  }
}
```

---

### 5. AudioTrack - éŸ³é¢‘è½¨é“

**èŒè´£**ï¼šå¤šé€šé“éŸ³é¢‘ç®¡ç†ï¼ˆè¯­éŸ³ã€éŸ³ä¹ã€éŸ³æ•ˆã€ç¯å¢ƒéŸ³ï¼‰

**é€šé“è§„åˆ™**ï¼ˆç”±å…¨å±€é…ç½®æ§åˆ¶ï¼‰ï¼š
| é€šé“ | æ’­æ”¾æ¨¡å¼ | å¾ªç¯ | éŸ³é‡æ¥æº | è¯´æ˜ |
|------|---------|------|----------|------|
| voice | æ›¿æ¢å¼ | å¦ | voice_volume | æ–°è¯­éŸ³åœæ­¢æ—§è¯­éŸ³ |
| music | æ›¿æ¢å¼ | æ˜¯ | music_volume | èƒŒæ™¯éŸ³ä¹ï¼Œå¾ªç¯æ’­æ”¾ |
| ambient | æ›¿æ¢å¼ | æ˜¯ | ambient_volume | ç¯å¢ƒéŸ³ï¼Œå¾ªç¯æ’­æ”¾ |
| sound | å¤šé‡æ’­æ”¾ | å¦ | sound_volume | å¯åŒæ—¶æ’­æ”¾å¤šä¸ªéŸ³æ•ˆ |

**å…¨å±€é…ç½®**ï¼ˆä»ç”¨æˆ·è®¾ç½®è¯»å–ï¼‰ï¼š
```typescript
interface AudioGlobalConfig {
  voice_volume: number;    // é…éŸ³éŸ³é‡ï¼Œé»˜è®¤ 1.0
  music_volume: number;    // éŸ³ä¹éŸ³é‡ï¼Œé»˜è®¤ 0.7
  sound_volume: number;    // éŸ³æ•ˆéŸ³é‡ï¼Œé»˜è®¤ 1.0
  ambient_volume: number;  // ç¯å¢ƒéŸ³éŸ³é‡ï¼Œé»˜è®¤ 0.7
}
```

**è¯´æ˜**ï¼š
- äº‹ä»¶ä¸­ä¸å†åŒ…å« `volume` å’Œ `loop` å‚æ•°
- éŸ³é‡å’Œå¾ªç¯æ’­æ”¾è§„åˆ™ç”±å‰ç«¯å…¨å±€é…ç½®å’Œé€šé“ç±»å‹å†³å®š
- ç”¨æˆ·å¯é€šè¿‡è®¾ç½®ç•Œé¢è°ƒæ•´å„é€šé“éŸ³é‡

```typescript
interface AudioConfig {
  url: string;
}

class AudioTrack {
  // å…¨å±€éŸ³é‡é…ç½®
  private volumeConfig: AudioGlobalConfig;
  
  private resourcePool: ResourcePool;
  
  // å•æ’­é€šé“ï¼ˆæ›¿æ¢å¼ï¼‰
  private singleChannels: Map<string, HTMLAudioElement> = new Map();
  
  // éŸ³æ•ˆæ± ï¼ˆå¤šé‡æ’­æ”¾ï¼‰
  private soundPool: Set<HTMLAudioElement> = new Set();
  
  // è¯­éŸ³å®Œæˆ Promise
  private voiceEndResolver?: () => void;

  constructor(resourcePool: ResourcePool, volumeConfig: AudioGlobalConfig) {
    this.resourcePool = resourcePool;
    this.volumeConfig = volumeConfig;
  }

  /**
   * æ›´æ–°éŸ³é‡é…ç½®
   */
  updateVolumeConfig(config: AudioGlobalConfig): void {
    this.volumeConfig = config;
    
    // æ›´æ–°å½“å‰æ’­æ”¾ä¸­çš„éŸ³é¢‘éŸ³é‡
    this.singleChannels.forEach((audio, channel) => {
      switch (channel) {
        case 'voice':
          audio.volume = config.voice_volume;
          break;
        case 'music':
          audio.volume = config.music_volume;
          break;
        case 'ambient':
          audio.volume = config.ambient_volume || config.sound_volume;
          break;
      }
    });
  }

  /**
   * æ’­æ”¾è¯­éŸ³ï¼ˆæ›¿æ¢å¼ï¼‰
   */
  async playVoice(voice: AudioConfig): Promise<void> {
    console.log('ğŸ¤ æ’­æ”¾è¯­éŸ³');
    
    // åœæ­¢å½“å‰è¯­éŸ³
    this.stopVoice();
    
    const audio = await this.resourcePool.waitFor(voice.url);
    if (!audio) return;
    
    audio.volume = this.volumeConfig.voice_volume;
    this.singleChannels.set('voice', audio);
    
    // è¯­éŸ³ç»“æŸå›è°ƒ
    audio.addEventListener('ended', () => {
      if (this.voiceEndResolver) {
        this.voiceEndResolver();
        this.voiceEndResolver = undefined;
      }
    }, { once: true });
    
    audio.play();
  }

  /**
   * ç­‰å¾…è¯­éŸ³æ’­æ”¾å®Œæˆ
   */
  waitForVoiceComplete(): Promise<void> {
    const voice = this.singleChannels.get('voice');
    if (!voice || voice.ended) {
      return Promise.resolve();
    }
    
    return new Promise(resolve => {
      this.voiceEndResolver = resolve;
    });
  }

  /**
   * åœæ­¢è¯­éŸ³
   */
  stopVoice(): void {
    this.stopChannel('voice');
  }

  /**
   * æ’­æ”¾èƒŒæ™¯éŸ³ä¹ï¼ˆæ›¿æ¢å¼ï¼Œå¾ªç¯ï¼‰
   */
  async playMusic(music: AudioConfig): Promise<void> {
    console.log('ğŸµ æ’­æ”¾éŸ³ä¹');
    
    this.stopChannel('music');
    
    const audio = await this.resourcePool.waitFor(music.url);
    if (!audio) return;
    
    audio.volume = this.volumeConfig.music_volume;
    audio.loop = true;
    this.singleChannels.set('music', audio);
    
    audio.play();
  }

  /**
   * æ’­æ”¾ç¯å¢ƒéŸ³ï¼ˆæ›¿æ¢å¼ï¼Œå¾ªç¯ï¼‰
   */
  async playAmbient(ambient: AudioConfig): Promise<void> {
    console.log('ğŸŒ¿ æ’­æ”¾ç¯å¢ƒéŸ³');
    
    this.stopChannel('ambient');
    
    const audio = await this.resourcePool.waitFor(ambient.url);
    if (!audio) return;
    
    audio.volume = this.volumeConfig.ambient_volume;
    audio.loop = true;
    this.singleChannels.set('ambient', audio);
    
    audio.play();
  }

  /**
   * æ’­æ”¾éŸ³æ•ˆï¼ˆå¤šé‡æ’­æ”¾ï¼Œå³å‘å³å¿˜ï¼‰
   */
  async playSound(sound: AudioConfig): Promise<void> {
    console.log('ğŸ”Š æ’­æ”¾éŸ³æ•ˆ');
    
    const audio = await this.resourcePool.waitFor(sound.url);
    if (!audio) return;
    
    // å…‹éš†éŸ³é¢‘å…ƒç´ ä»¥æ”¯æŒå¤šé‡æ’­æ”¾
    const clone = audio.cloneNode() as HTMLAudioElement;
    clone.volume = this.volumeConfig.sound_volume;
    clone.loop = false;  // éŸ³æ•ˆä¸å¾ªç¯
    
    this.soundPool.add(clone);
    
    clone.addEventListener('ended', () => {
      this.soundPool.delete(clone);
    }, { once: true });
    
    clone.play();
  }

  /**
   * åœæ­¢é€šé“
   */
  stop(channel: string, fadeOut?: number): void {
    if (channel === 'sound') {
      // åœæ­¢æ‰€æœ‰éŸ³æ•ˆ
      this.soundPool.forEach(audio => {
        this.stopAudio(audio, fadeOut);
      });
      this.soundPool.clear();
    } else {
      this.stopChannel(channel, fadeOut);
    }
  }

  /**
   * åœæ­¢å•æ’­é€šé“
   */
  private stopChannel(channel: string, fadeOut?: number): void {
    const audio = this.singleChannels.get(channel);
    if (audio) {
      this.stopAudio(audio, fadeOut);
      this.singleChannels.delete(channel);
    }
  }

  /**
   * åœæ­¢å•ä¸ªéŸ³é¢‘
   */
  private async stopAudio(audio: HTMLAudioElement, fadeOut?: number): Promise<void> {
    if (fadeOut && fadeOut > 0) {
      await this.fadeOut(audio, fadeOut);
    }
    audio.pause();
    audio.currentTime = 0;
  }

  /**
   * æ·¡å…¥æ•ˆæœ
   * @param audio éŸ³é¢‘å…ƒç´ 
   * @param duration æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰
   */
  private async fadeIn(audio: HTMLAudioElement, duration?: number): Promise<void> {
    if (!duration || duration <= 0) return;
    
    const targetVolume = audio.volume;
    audio.volume = 0;
    
    const steps = 20;
    const stepTime = (duration * 1000) / steps;  // è½¬æ¢ä¸ºæ¯«ç§’
    const stepVolume = targetVolume / steps;
    
    for (let i = 0; i < steps; i++) {
      await this.sleep(stepTime);
      audio.volume = Math.min(audio.volume + stepVolume, targetVolume);
    }
  }

  /**
   * æ·¡å‡ºæ•ˆæœ
   * @param audio éŸ³é¢‘å…ƒç´ 
   * @param duration æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰
   */
  private async fadeOut(audio: HTMLAudioElement, duration: number): Promise<void> {
    const startVolume = audio.volume;
    const steps = 20;
    const stepTime = (duration * 1000) / steps;  // è½¬æ¢ä¸ºæ¯«ç§’
    const stepVolume = startVolume / steps;
    
    for (let i = 0; i < steps; i++) {
      await this.sleep(stepTime);
      audio.volume = Math.max(audio.volume - stepVolume, 0);
    }
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

---

## åŸå­ç»„ä»¶

### LayerManager - å›¾å±‚ç®¡ç†

**æ”¯æŒå›¾åƒå’Œè§†é¢‘è§’è‰²çš„æ˜¾ç¤º/éšè—**

```typescript
interface TransitionOptions {
  type?: 'fade_in' | 'fade_out' | 'none';
  duration?: number;  // ç§’ï¼Œé»˜è®¤ 0.3s
}

interface ShowElementOptions {
  layer?: 'background' | 'characters' | 'effects';  // å›¾å±‚ç±»å‹
  position?: 'left' | 'center' | 'right';
  mediaType?: 'image' | 'animated_image' | 'video';
  loop?: boolean;
  muted?: boolean;
  autoplay?: boolean;
  transition?: TransitionOptions;
}

class LayerManager {
  private layers: Map<string, HTMLElement> = new Map();

  /**
   * æ˜¾ç¤ºå…ƒç´ ï¼ˆå›¾åƒæˆ–è§†é¢‘è§’è‰²ï¼‰
   * @param elementId å…ƒç´ ID
   * @param element å›¾åƒæˆ–è§†é¢‘å…ƒç´ 
   * @param options æ˜¾ç¤ºé€‰é¡¹
   */
  async showElement(
    elementId: string,
    element: HTMLImageElement | HTMLVideoElement,
    options: ShowElementOptions = {}
  ): Promise<void> {
    const container = document.getElementById('layer-container');
    const { 
      position = 'center', 
      mediaType, 
      loop = true, 
      muted = true, 
      autoplay = true,
      transition = { type: 'fade_in', duration: 0.3 }
    } = options;
    
    // å¦‚æœå·²å­˜åœ¨åŒIDå…ƒç´ ï¼Œå…ˆç§»é™¤
    if (this.layers.has(elementId)) {
      await this.hideElement(elementId);
    }
    
    element.id = elementId;
    element.style.position = 'absolute';
    element.style.opacity = '0';
    element.style.bottom = '0';
    
    // è®¾ç½®æ°´å¹³ä½ç½®
    switch (position) {
      case 'left':
        element.style.left = '15%';
        element.style.transform = 'translateX(-50%)';
        break;
      case 'right':
        element.style.left = '85%';
        element.style.transform = 'translateX(-50%)';
        break;
      default:  // center
        element.style.left = '50%';
        element.style.transform = 'translateX(-50%)';
    }
    
    // è§†é¢‘è§’è‰²ç‰¹æ®Šå¤„ç†
    if (element instanceof HTMLVideoElement) {
      element.loop = loop;
      element.muted = muted;
      element.playsInline = true;
      
      if (autoplay) {
        try {
          await element.play();
        } catch (e) {
          console.warn('è§†é¢‘è‡ªåŠ¨æ’­æ”¾å¤±è´¥ï¼Œå¯èƒ½éœ€è¦ç”¨æˆ·äº¤äº’:', e);
        }
      }
    }
    
    container?.appendChild(element);
    this.layers.set(elementId, element);
    
    // æ·¡å…¥åŠ¨ç”»ï¼ˆæ”¯æŒå¯é…ç½®æ—¶é•¿ï¼‰
    if (transition.type !== 'none') {
      await this.fadeIn(element, transition.duration);
    } else {
      element.style.opacity = '1';
    }
  }

  /**
   * éšè—å…ƒç´ 
   * @param elementId å…ƒç´ ID
   * @param transition è½¬åœºé…ç½®
   */
  async hideElement(elementId: string, transition?: TransitionOptions): Promise<void> {
    const element = this.layers.get(elementId);
    if (element) {
      // å¦‚æœæ˜¯è§†é¢‘ï¼Œå…ˆæš‚åœæ’­æ”¾
      if (element instanceof HTMLVideoElement) {
        element.pause();
        element.currentTime = 0;
      }
      
      const duration = transition?.duration ?? 0.3;
      if (transition?.type !== 'none') {
        await this.fadeOut(element, duration);
      }
      element.remove();
      this.layers.delete(elementId);
    }
  }

  /**
   * éšè—æ‰€æœ‰å…ƒç´ 
   */
  hideAll(): void {
    this.layers.forEach((element) => {
      // æš‚åœæ‰€æœ‰è§†é¢‘
      if (element instanceof HTMLVideoElement) {
        element.pause();
      }
      element.remove();
    });
    this.layers.clear();
  }

  /**
   * æ·¡å…¥æ•ˆæœ
   * @param element ç›®æ ‡å…ƒç´ 
   * @param duration æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤ 0.3s
   */
  private async fadeIn(element: HTMLElement, duration: number = 0.3): Promise<void> {
    return new Promise(resolve => {
      element.style.transition = `opacity ${duration}s`;
      element.style.opacity = '1';
      setTimeout(resolve, duration * 1000);
    });
  }

  /**
   * æ·¡å‡ºæ•ˆæœ
   * @param element ç›®æ ‡å…ƒç´ 
   * @param duration æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤ 0.3s
   */
  private async fadeOut(element: HTMLElement, duration: number = 0.3): Promise<void> {
    return new Promise(resolve => {
      element.style.transition = `opacity ${duration}s`;
      element.style.opacity = '0';
      setTimeout(resolve, duration * 1000);
    });
  }
}
```

### AudioManager - å¤šé€šé“éŸ³é¢‘ç®¡ç†

**æ”¯æŒä¸‰ç§é€šé“ç±»å‹**ï¼š
- `music`ï¼šæ›¿æ¢å¼ï¼Œå¾ªç¯æ’­æ”¾
- `sound`ï¼šå¤šé‡æ’­æ”¾ï¼Œå³å‘å³å¿˜
- `ambient`ï¼šæ›¿æ¢å¼ï¼Œå¾ªç¯æ’­æ”¾
- `voice`ï¼šæ›¿æ¢å¼ï¼Œå¯¹è¯è¯­éŸ³

```typescript
interface PlayOptions {
  soundId?: string;
  volume?: number;
  loop?: boolean;
  fadeIn?: number;
}

class AudioManager {
  // æ›¿æ¢å¼é€šé“ï¼ˆmusic, ambient, voiceï¼‰
  private singleChannels: Map<string, HTMLAudioElement> = new Map();
  // å¤šé‡æ’­æ”¾é€šé“ï¼ˆsoundï¼‰- å¯åŒæ—¶æ’­æ”¾å¤šä¸ª
  private soundPool: Map<string, HTMLAudioElement> = new Map();

  /**
   * æ’­æ”¾éŸ³é¢‘
   */
  play(channel: string, audio: HTMLAudioElement, options: PlayOptions = {}): void {
    const { soundId, volume = 1.0, loop = false, fadeIn } = options;

    audio.volume = fadeIn ? 0 : volume;
    audio.loop = loop;

    if (channel === 'sound') {
      // sound é€šé“ï¼šå¤šé‡æ’­æ”¾ï¼Œå¯åŒæ—¶æ’­æ”¾å¤šä¸ª
      const id = soundId || `sound_${Date.now()}`;
      this.soundPool.set(id, audio);
      
      audio.play();
      
      // æ’­æ”¾å®Œæˆåè‡ªåŠ¨æ¸…ç†ï¼ˆéå¾ªç¯ï¼‰
      if (!loop) {
        audio.addEventListener('ended', () => {
          this.soundPool.delete(id);
        }, { once: true });
      }
    } else {
      // å…¶ä»–é€šé“ï¼šæ›¿æ¢å¼ï¼Œæ–°éŸ³é¢‘æ›¿æ¢æ—§éŸ³é¢‘
      if (this.singleChannels.has(channel)) {
        const old = this.singleChannels.get(channel)!;
        old.pause();
        old.currentTime = 0;
      }
      
      this.singleChannels.set(channel, audio);
      audio.play();
    }

    // æ·¡å…¥æ•ˆæœ
    if (fadeIn) {
      this.fadeIn(audio, volume, fadeIn);
    }
  }

  /**
   * æ³¨å†ŒéŸ³é¢‘åˆ°é€šé“ï¼ˆç”¨äº voice ç­‰éœ€è¦è¿½è¸ªçš„åœºæ™¯ï¼‰
   */
  registerAudio(channel: string, audio: HTMLAudioElement): void {
    if (this.singleChannels.has(channel)) {
      const old = this.singleChannels.get(channel)!;
      old.pause();
    }
    this.singleChannels.set(channel, audio);
  }

  /**
   * åœæ­¢éŸ³é¢‘
   */
  stop(channel: string, soundId?: string, fadeOut?: number): void {
    if (channel === 'sound' && soundId) {
      // åœæ­¢ç‰¹å®šéŸ³æ•ˆ
      const audio = this.soundPool.get(soundId);
      if (audio) {
        if (fadeOut) {
          this.fadeOutAndStop(audio, fadeOut);
        } else {
          audio.pause();
        }
        this.soundPool.delete(soundId);
      }
    } else if (channel === 'sound') {
      // åœæ­¢æ‰€æœ‰éŸ³æ•ˆ
      this.soundPool.forEach(audio => {
        audio.pause();
      });
      this.soundPool.clear();
    } else {
      // åœæ­¢å•é€šé“éŸ³é¢‘
      const audio = this.singleChannels.get(channel);
      if (audio) {
        if (fadeOut) {
          this.fadeOutAndStop(audio, fadeOut);
        } else {
          audio.pause();
          audio.currentTime = 0;
        }
        this.singleChannels.delete(channel);
      }
    }
  }

  private fadeIn(audio: HTMLAudioElement, targetVolume: number, duration: number): void {
    const step = 0.05;
    const interval = (duration * 1000) / (targetVolume / step);
    
    const timer = setInterval(() => {
      if (audio.volume < targetVolume - step) {
        audio.volume += step;
      } else {
        audio.volume = targetVolume;
        clearInterval(timer);
      }
    }, interval);
  }

  private fadeOutAndStop(audio: HTMLAudioElement, duration: number): void {
    const step = 0.05;
    const interval = (duration * 1000) / (audio.volume / step);
    
    const timer = setInterval(() => {
      if (audio.volume > step) {
        audio.volume -= step;
      } else {
        clearInterval(timer);
        audio.pause();
        audio.currentTime = 0;
      }
    }, interval);
  }
}
```

### TextRenderer - æ–‡å­—æ¸²æŸ“

**æ”¯æŒä¸­æ–­æœºåˆ¶ï¼Œç”¨æˆ·ç‚¹å‡»æ¨è¿›æ—¶ç«‹å³åœæ­¢æ‰“å­—æœºæ•ˆæœå’ŒAFMç­‰å¾…**

```typescript
class TextRenderer {
  private currentDialogue: DialogueData | null = null;
  private isTyping = false;

  /**
   * æ˜¾ç¤ºå¯¹è¯
   * @param data å¯¹è¯æ•°æ®
   * @param signal ä¸­æ–­ä¿¡å·ï¼ˆç”¨æˆ·ç‚¹å‡»æ¨è¿›æ—¶è§¦å‘ï¼‰
   */
  async showDialogue(data: DialogueData, signal?: AbortSignal): Promise<void> {
    this.currentDialogue = data;
    this.isTyping = true;

    try {
      // æ‰“å­—æœºæ•ˆæœï¼ˆå¯ä¸­æ–­ï¼‰
      await this.typewriterEffect(data.text, data.textSpeed, signal);
      this.isTyping = false;

      // æ£€æŸ¥æ˜¯å¦è¢«ä¸­æ–­
      if (signal?.aborted) {
        this.showFullText(data.text);  // ç«‹å³æ˜¾ç¤ºå®Œæ•´æ–‡æœ¬
        return;
      }

      // AFM å»¶è¿Ÿï¼ˆå¯ä¸­æ–­ï¼‰
      if (data.afmEnable) {
        const delay = this.calculateAfmDelay(data.text, data.afmTime, data.voiceDuration);
        await this.interruptableSleep(delay, signal);
      }
    } catch (e) {
      if (e instanceof DOMException && e.name === 'AbortError') {
        this.showFullText(data.text);  // è¢«ä¸­æ–­æ—¶æ˜¾ç¤ºå®Œæ•´æ–‡æœ¬
        this.isTyping = false;
        throw e;  // å‘ä¸Šä¼ é€’ä¸­æ–­ä¿¡å·
      }
      throw e;
    }
  }

  /**
   * ç«‹å³æ˜¾ç¤ºå®Œæ•´æ–‡æœ¬ï¼ˆè·³è¿‡æ‰“å­—æœºæ•ˆæœï¼‰
   */
  private showFullText(text: string): void {
    const container = document.getElementById('dialogue-text');
    if (container) {
      container.textContent = text;
    }
  }

  /**
   * æ‰“å­—æœºæ•ˆæœï¼ˆå¯ä¸­æ–­ï¼‰
   */
  private async typewriterEffect(text: string, speed: number, signal?: AbortSignal): Promise<void> {
    const container = document.getElementById('dialogue-text');
    if (!container) return;
    
    container.textContent = '';

    for (let i = 0; i < text.length; i++) {
      // æ£€æŸ¥ä¸­æ–­ä¿¡å·
      if (signal?.aborted) {
        throw new DOMException('Typewriter aborted', 'AbortError');
      }
      
      container.textContent += text[i];
      await this.sleep(1000 / speed);
    }
  }

  /**
   * è®¡ç®— AFM å»¶è¿Ÿæ—¶é—´
   * - å¦‚æœæœ‰é…éŸ³ï¼Œç­‰å¾…é…éŸ³æ’­å®Œ + é¢å¤–å»¶è¿Ÿ
   * - å¦‚æœæ²¡æœ‰é…éŸ³ï¼Œæ ¹æ®æ–‡æœ¬é•¿åº¦è®¡ç®—
   */
  private calculateAfmDelay(text: string, afmTime: number, voiceDuration?: number): number {
    if (voiceDuration) {
      // é…éŸ³æ—¶é•¿ï¼ˆæ¯«ç§’ï¼‰+ é¢å¤–å»¶è¿Ÿ
      return voiceDuration * 1000 + afmTime * 100;
    } else {
      // åŸºç¡€å»¶è¿Ÿ + æ¯å­—ç¬¦å»¶è¿Ÿ
      return 1000 + text.length * afmTime * 10;
    }
  }

  /**
   * å¯ä¸­æ–­çš„å»¶è¿Ÿ
   */
  private interruptableSleep(ms: number, signal?: AbortSignal): Promise<void> {
    return new Promise((resolve, reject) => {
      if (signal?.aborted) {
        reject(new DOMException('Sleep aborted', 'AbortError'));
        return;
      }

      const timer = setTimeout(resolve, ms);

      signal?.addEventListener('abort', () => {
        clearTimeout(timer);
        reject(new DOMException('Sleep aborted', 'AbortError'));
      }, { once: true });
    });
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

---

## å®Œæ•´æµç¨‹ç¤ºä¾‹

### dialogue äº‹ä»¶å¤„ç†ï¼ˆè§’è‰²å±•ç¤ºï¼‰

```
1. æ”¶åˆ° dialogue äº‹ä»¶ï¼ˆshow å­—æ®µåŒ…å«é™æ€å›¾ã€åŠ¨å›¾æˆ–è§†é¢‘ï¼‰
    â†“
2. NarrativeEventParser è§£æ
   operations: [show(character), play(voice), say(text)]
   resources: [{url, type: 'image'}, {url, type: 'audio'}]
   cleanup: [stop(voice), hide(image)]
    â†“
3. ResourcePool å¹¶è¡Œç­‰å¾…èµ„æº
   await Promise.all([
     resourcePool.waitFor(image.url),  // è¿”å› HTMLImageElement
     resourcePool.waitFor(voice.url)
   ])
    â†“
4. æ‰§è¡ŒåŸå­æ“ä½œ
   - layerManager.showElement(image)  // æ˜¾ç¤ºå›¾åƒ
   - audio.play()                     // æ’­æ”¾é…éŸ³
   - textRenderer.showDialogue(...)   // æ‰“å­—æœº+AFM
    â†“
5. æ‰§è¡Œæ¸…ç†
   - audioManager.stop('voice')
   - layerManager.hideElement(character_id)
```

### dialogue äº‹ä»¶å¤„ç†ï¼ˆè§†é¢‘è§’è‰²ï¼‰

```
1. æ”¶åˆ° dialogue äº‹ä»¶ï¼ˆmedia.type = 'video'ï¼‰
    â†“
2. NarrativeEventParser è§£æ
   operations: [show(video, {loop, muted, autoplay}), play(voice), say(text)]
   resources: [{url, type: 'video'}, {url, type: 'audio'}]
   cleanup: [stop(voice), hide(video)]
    â†“
3. ResourcePool å¹¶è¡Œç­‰å¾…èµ„æº
   await Promise.all([
     resourcePool.waitFor(video.url),  // è¿”å› HTMLVideoElement
     resourcePool.waitFor(voice.url)
   ])
    â†“
4. æ‰§è¡ŒåŸå­æ“ä½œ
   - layerManager.showElement(video, {loop: true, muted: true, autoplay: true})
     â””â”€ video.play() è‡ªåŠ¨æ’­æ”¾é€æ˜è§†é¢‘è§’è‰²
   - audio.play()                     // æ’­æ”¾é…éŸ³ï¼ˆä¸è§†é¢‘åˆ†ç¦»ï¼‰
   - textRenderer.showDialogue(...)   // æ‰“å­—æœº+AFM
    â†“
5. æ‰§è¡Œæ¸…ç†
   - audioManager.stop('voice')
   - layerManager.hideElement(character_id)
     â””â”€ video.pause() æš‚åœè§†é¢‘
```

> **è§†é¢‘è§’è‰²è¯´æ˜**ï¼š
> - è§†é¢‘è§’è‰²ä½¿ç”¨é€æ˜ WebM æ ¼å¼ï¼Œæ”¯æŒ Alpha é€šé“
> - è§†é¢‘é»˜è®¤é™éŸ³ï¼ˆ`muted: true`ï¼‰ï¼Œé…éŸ³ç”±ç‹¬ç«‹çš„ voice å­—æ®µæä¾›
> - è§†é¢‘å¾ªç¯æ’­æ”¾ï¼ˆ`loop: true`ï¼‰ï¼Œè§’è‰²æŒç»­åŠ¨æ€å±•ç¤º
> - å‰ç«¯ä½¿ç”¨ `<video>` æ ‡ç­¾æ¸²æŸ“ï¼Œè‡ªåŠ¨ä¸èƒŒæ™¯/å…¶ä»–å…ƒç´ åˆæˆ

---

## ç”¨æˆ·äº¤äº’æ§åˆ¶

### äº¤äº’è¡Œä¸ºå®šä¹‰

| æ“ä½œ | è¡Œä¸º | è¯´æ˜ |
|------|------|------|
| **ç‚¹å‡»æ¨è¿›** | è·³è¿‡å½“å‰äº‹ä»¶ | åœæ­¢é…éŸ³ã€è·³è¿‡æ‰“å­—æœºæ•ˆæœå’ŒAFMç­‰å¾…ï¼Œæ‰§è¡Œæ¸…ç†åè¿›å…¥ä¸‹ä¸€äº‹ä»¶ |
| **æš‚åœ** | æš‚åœæ’­æ”¾é˜Ÿåˆ— | å½“å‰äº‹ä»¶æ’­æ”¾å®Œæˆåæš‚åœï¼Œä¸è‡ªåŠ¨è¿›å…¥ä¸‹ä¸€äº‹ä»¶ |
| **ç»§ç»­** | ç»§ç»­æ’­æ”¾é˜Ÿåˆ— | ä»æš‚åœçŠ¶æ€æ¢å¤ï¼Œç»§ç»­å¤„ç†åç»­äº‹ä»¶ |

### ç”¨æˆ·äº¤äº’æµç¨‹

```
ç”¨æˆ·ç‚¹å‡»æ¨è¿›
    â†“
playbackQueue.skipCurrent()
    â†“
AbortController.abort() è§¦å‘ä¸­æ–­ä¿¡å·
    â†“
TextRenderer æ”¶åˆ°ä¸­æ–­ä¿¡å·
    â”œâ”€ åœæ­¢æ‰“å­—æœºæ•ˆæœ
    â”œâ”€ ç«‹å³æ˜¾ç¤ºå®Œæ•´æ–‡æœ¬
    â””â”€ è·³è¿‡ AFM ç­‰å¾…
    â†“
PlaybackQueue æ‰§è¡Œæ¸…ç†è§„åˆ™
    â”œâ”€ åœæ­¢é…éŸ³ audioManager.stop('voice')
    â””â”€ éšè—è§’è‰² layerManager.hideElement(...)
    â†“
è‡ªåŠ¨è¿›å…¥ä¸‹ä¸€äº‹ä»¶ï¼ˆAFM æ¨¡å¼ä¿æŒä¸å˜ï¼‰
```

### ä½¿ç”¨ç¤ºä¾‹

```typescript
// åˆå§‹åŒ–æ’­æ”¾é˜Ÿåˆ—
const playbackQueue = new PlaybackQueue(resourcePool, context);

// ç»‘å®šç”¨æˆ·äº¤äº’äº‹ä»¶
document.addEventListener('click', () => {
  playbackQueue.skipCurrent();  // ç‚¹å‡»æ¨è¿›
});

document.getElementById('pause-btn')?.addEventListener('click', () => {
  if (playbackQueue.paused) {
    playbackQueue.resume();  // ç»§ç»­
  } else {
    playbackQueue.pause();   // æš‚åœ
  }
});

// æ¥æ”¶äº‹ä»¶å¹¶å…¥é˜Ÿ
dataManager.onStoryEventReceived((event) => {
  playbackQueue.enqueue(event);
});
```

### æš‚åœçŠ¶æ€ UI æç¤º

```typescript
// ç›‘å¬æš‚åœçŠ¶æ€å˜åŒ–ï¼Œæ›´æ–° UI
useEffect(() => {
  const updateUI = () => {
    setPauseButtonText(playbackQueue.paused ? 'â–¶ï¸ ç»§ç»­' : 'â¸ï¸ æš‚åœ');
  };
  // å¯é€šè¿‡äº‹ä»¶æˆ–è½®è¯¢ç›‘å¬çŠ¶æ€
}, []);
```

---

## æŠ€æœ¯æ ˆ

- **æ¡†æ¶**ï¼šReact 18+ (TypeScript)
- **çŠ¶æ€ç®¡ç†**ï¼šZustand
- **èµ„æºç¼“å­˜**ï¼šIndexedDB
- **éŸ³é¢‘ç®¡ç†**ï¼šHowler.js
- **æ„å»ºå·¥å…·**ï¼šVite

---

**è¯¦ç»†çš„ API æ¥å£è¯·å‚è€ƒ api.md**
