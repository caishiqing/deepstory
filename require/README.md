# AI驱动视觉小说系统 - 架构设计

## 项目概述

基于大语言模型驱动的实时视觉小说系统，用户通过创意简介启动故事，AI 实时生成剧情、对话、图像和语音，用户通过选择影响故事走向。

---

## 文档导航

| 文档 | 内容 | 适用人员 |
|------|------|---------|
| **README.md**（本文档）| 架构设计、核心概念 | 所有人员 |
| **api.md** | API接口、SSE事件格式 | 前后端开发 |
| **frontend.md** | 前端实现细节 | 前端开发 |
| **backend.md** | 后端实现细节 | 后端开发 |

---

## 系统整体架构

### 分层架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                        客户端层                              │
│  ┌───────────────────────────────────────────────────┐      │
│  │  前端应用 (React + TypeScript)                     │      │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐        │      │
│  │  │ UI组件层 │  │ 播放引擎 │  │资源管理器│        │      │
│  │  └──────────┘  └──────────┘  └──────────┘        │      │
│  └───────────────────────────────────────────────────┘      │
└───────────────────────┬─────────────────────────────────────┘
                        │ SSE 推送 + HTTP API
┌───────────────────────┴─────────────────────────────────────┐
│                      服务端层                                │
│  ┌───────────────────────────────────────────────────┐      │
│  │  API服务 (FastAPI)                                 │      │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐        │      │
│  │  │ SSE推送  │  │REST API  │  │ 认证服务 │        │      │
│  │  └──────────┘  └──────────┘  └──────────┘        │      │
│  └───────────────────────────────────────────────────┘      │
│                                                              │
│  ┌───────────────────────────────────────────────────┐      │
│  │  AI生成引擎                                        │      │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐        │      │
│  │  │剧情生成  │  │图像生成  │  │语音生成  │        │      │
│  │  └──────────┘  └──────────┘  └──────────┘        │      │
│  └───────────────────────────────────────────────────┘      │
│                                                              │
│  ┌───────────────────────────────────────────────────┐      │
│  │  基础设施                                          │      │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐        │      │
│  │  │Redis队列 │  │ CDN存储  │  │PostgreSQL│        │      │
│  │  └──────────┘  └──────────┘  └──────────┘        │      │
│  └───────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────┘
```

### 服务端与AI交互架构

```
┌──────────────┐
│   用户请求   │
└──────┬───────┘
       │ 创意简介
┌──────▼──────────────────────────────────────────┐
│            FastAPI 服务                          │
│  ┌──────────────────────────────────────┐       │
│  │      AI 故事生成器                    │       │
│  │  ┌────────────────────────────┐      │       │
│  │  │  Prompt Engineering        │      │       │
│  │  │  - 系统提示词              │      │       │
│  │  │  - 上下文管理              │      │       │
│  │  │  - 角色设定                │      │       │
│  │  └────────┬───────────────────┘      │       │
│  └───────────┼──────────────────────────┘       │
└──────────────┼──────────────────────────────────┘
               │
       ┌───────▼────────┐
       │  LLM API 调用   │ (OpenAI / Claude / 自托管)
       └───────┬────────┘
               │ 1. 思考规划（保存到stories.think）
               │ 2. 生成结构化脚本（保存到stories.script）
               │ 3. 流式返回详细剧本
┌──────────────▼──────────────────────────────────┐
│         叙事事件生成器                           │
│  ┌──────────────┐  ┌──────────────┐            │
│  │ 脚本解析器   │  │ 资源生成器   │            │
│  │ - 解析剧本   │  │ - 图像生成   │            │
│  │ - 提取事件   │  │ - 语音合成   │            │
│  │ - 事件排序   │  │ - CDN上传    │            │
│  └──────┬───────┘  └──────┬───────┘            │
│         │                  │                     │
│         └────────┬─────────┘                     │
│                  │ 叙事事件 + 资源URL            │
│         ┌────────▼─────────┐                     │
│         │  事件打包器      │                     │
│         │  - scene_start   │                     │
│         │  - dialogue      │                     │
│         │  - narration     │                     │
│         └────────┬─────────┘                     │
└──────────────────┼──────────────────────────────┘
                   │
         ┌─────────▼──────────┐
         │   Redis Stream     │
         │  (消息队列)        │
         └─────────┬──────────┘
                   │
         ┌─────────▼──────────┐
         │    SSE 推送        │
         │  (实时传输)        │
         └─────────┬──────────┘
                   │
         ┌─────────▼──────────┐
         │     前端接收       │
         └────────────────────┘
```

---

## 故事类型

本系统支持两种故事类型：

| 类型 | 说明 | 分支选择 | 版本管理 |
|------|------|---------|---------|
| `linear` | **线性叙事** | ❌ 无 choice 事件 | ❌ 不使用 story_versions |
| `interactive` | **互动叙事** | ✅ 支持 choice 事件 | ✅ 使用 story_versions |

### 线性叙事 (linear)

- 传统视觉小说的线性体验
- 故事从头到尾只有一条路径
- 无需版本管理，性能开销最小
- 状态流转：`pending → generating → completed`

### 互动叙事 (interactive)

- 支持分支选择的互动体验
- 用户选择影响故事走向
- 通过 `story_versions` 表管理分支版本
- 状态流转：`pending → generating → dynamic → completed`
- 支持分支共享：其他用户可以播放已开拓的分支

---

## 核心概念

### 叙事队列 + 媒体轨道架构

前端采用「叙事队列调度 + 媒体轨道播放」架构，实现事件、资源、轨道解耦：

```
┌─────────────────────────────────────────────────────────────┐
│                      前端播放器                              │
│                                                              │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  叙事队列 (NarrativeQueue)                              │ │
│  │  顺序处理所有事件，叙事事件阻塞队列等待用户推进            │ │
│  └────────────────────────────────────────────────────────┘ │
│           ↓ 根据资源类型分发                                  │
│  ┌──────────────┬──────────────┬──────────────┐            │
│  │  TextTrack   │ VisualTrack  │  AudioTrack  │            │
│  │  文本渲染    │ 视觉播放     │  音频播放    │            │
│  ├──────────────┼──────────────┼──────────────┤            │
│  │ text         │ image        │ voice        │            │
│  │              │ background   │ music        │            │
│  │              │ video        │ ambient      │            │
│  │              │              │ sound        │            │
│  └──────────────┴──────────────┴──────────────┘            │
└─────────────────────────────────────────────────────────────┘
```

**核心机制**：

| 组件 | 职责 | 说明 |
|------|------|------|
| **NarrativeQueue** | 叙事流程调度 | 叙事事件阻塞，非叙事事件不阻塞 |
| **TextTrack** | 文本渲染 | 打字机效果，替换式 |
| **VisualTrack** | 视觉播放 | 场景替换、图像叠加、视频阻塞 |
| **AudioTrack** | 音频播放 | voice/music/ambient 替换式，sound 多重播放 |

---

## 事件树形结构

### 设计原理

互动叙事的核心是**分支叙事**，本系统采用树形结构维护故事事件：

```
核心字段：
  - sequence_id: 全局唯一ID（ULID），不编码业务逻辑
  - path_id: 分支路径ID（8位字符，如 "root0000", "a1b2c3d4"）
  - next_sequence_id: 指向下一个事件（链式结构）

遍历方式：
  1. 查询起点：WHERE story_id=xxx AND event_type='story_start'
  2. 链式遍历：通过 next_sequence_id 逐个查询（O(1) per event）
  3. 分支跳转：choice 事件的 options[].next_sequence_id 指向不同分支
```

**兼容性**：
- ✅ **线性叙事**：path_id 固定为 `"root0000"`，事件通过 next_sequence_id 链接
- ✅ **分支叙事**：每个 choice 选项创建新的 path_id，形成树形结构

### 原生AI互动叙事：只关注当前状态

**核心设计理念**：
- 📍 **只记录位置**：用户当前在故事的哪个事件（current_event_id）
- 🚫 **不记录路径**：不关心用户是怎么到达当前位置的
- 🔄 **统一推进**：通过有向图链式遍历，根据 next_sequence_id 自动推进
- 🎮 **重新选择**：每次遇到 choice 事件，用户都重新选择

**推进策略**：
```
遍历事件流 → 遇到 choice → 暂停推送 → 等待用户选择 
  → 根据 option.next_sequence_id 跳转 → 继续遍历
```

**特点**：
- ✅ **简洁性**：只关注"用户在哪里"，不关注"用户怎么来的"
- ✅ **灵活性**：每次遇到分支都是新的选择，每次游玩可能不同
- ✅ **可重玩**：用户可以多次游玩，探索不同路径和结局
- ✅ **原生AI**：故事由AI动态生成，分支按需创建，没有预设路径

---

## 事件类型清单

### 事件分类

| 分类 | narrative | 事件类型 | 说明 |
|------|-----------|---------|------|
| **叙事事件** | `true` | dialogue, narration, choice | 阻塞队列，等待用户推进 |
| **非叙事事件** | `false` | scene_start, scene_end, show, hide, play_video, play_audio, stop_audio | 触发后立即处理下一个 |
| **控制事件** | `false` | story_start, story_end, chapter_start, chapter_end | 流程控制 |
| **系统事件** | - | heartbeat, error | 系统状态（system_event）|

### 叙事事件（阻塞队列）

| 事件类型 | 用途 | 可包含资源 |
|---------|------|-----------|
| `dialogue` | 对话 | text, voice, image |
| `narration` | 旁白 | text, voice |
| `choice` | 用户选择 | prompt, options |

### 非叙事事件（不阻塞）

| 事件类型 | 用途 | 可包含资源 | 说明 |
|---------|------|-----------|------|
| `scene_start` | 场景开始 | background, music, ambient | 清理上一场景后显示新场景 |
| `scene_end` | 场景结束 | transition | 淡出音频，清理场景 |
| `show` | 显示图片 | element | 立即完成，持续显示 |
| `hide` | 隐藏图片 | element_id | 立即完成 |
| `play_video` | 播放视频 | video | 视觉轨道内替换式播放 |
| `play_audio` | 播放音频 | audio, channel | 支持 sound/music/ambient 通道 |
| `stop_audio` | 停止音频 | channel | 停止指定通道音频 |

### 控制事件

| 事件类型 | 用途 | 说明 |
|---------|------|------|
| `story_start` | 故事开始 | 初始化故事信息 |
| `story_end` | 故事结束 | 关闭SSE连接（某个分支结束）|
| `chapter_start` | 章节开始 | 显示章节标题，标记新章节 |
| `chapter_end` | 章节结束 | 可选显示章节总结 |

**章节说明**：
- 章节是叙事的基本组织单位，提供清晰的叙事节点
- **线性故事**：章节预设在 script 中，顺序推进（如：第一章、第二章、第三章）
- **动态分支故事**：章节根据用户选择动态生成
  - 不同分支可能进入不同的章节
  - 某些章节可能只在特定分支中出现
  - 章节可以跨分支共享（多条路径汇聚到同一章节）

### System 事件（2种）

| 事件类型 | 用途 | 说明 |
|---------|------|------|
| `heartbeat` | 心跳包 | 保持连接活跃（每30秒）|
| `error` | 错误通知 | 系统错误 |

> **注**：创作阶段的等待状态通过短轮询 `GET /status` 接口获取，不再使用 SSE 事件。

---

## 前端架构

### 核心模块架构

```
┌──────────────────────────────────────────────────────────────┐
│              VisualNovelPlayer (主组件)                       │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                    UI 层                                 │ │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐              │ │
│  │  │  文字框  │  │  选择UI  │  │  控制栏  │              │ │
│  │  └──────────┘  └──────────┘  └──────────┘              │ │
│  └─────────────────────────────────────────────────────────┘ │
│                                                               │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              核心引擎层                                  │ │
│  │  ┌────────────────────────────────────────────────┐    │ │
│  │  │           DataManager (SSE接收)                 │    │ │
│  │  └──────────────────────┬─────────────────────────┘    │ │
│  │                         ↓                               │ │
│  │  ┌────────────────────────────────────────────────┐    │ │
│  │  │         BufferController (缓冲控制)             │    │ │
│  │  │  初始缓冲 → 缓存N个叙事事件 → 开始播放          │    │ │
│  │  └──────────────────────┬─────────────────────────┘    │ │
│  │                         ↓                               │ │
│  │  ┌────────────────────────────────────────────────┐    │ │
│  │  │         NarrativeQueue (叙事队列)               │    │ │
│  │  │  顺序处理事件，narrative=true 阻塞队列          │    │ │
│  │  └──┬─────────────────┬─────────────────┬─────────┘    │ │
│  │     │ track='text'    │ track='visual'  │ track='audio'│ │
│  │     ↓                 ↓                 ↓               │ │
│  │  ┌──────────┐   ┌──────────┐   ┌──────────┐           │ │
│  │  │文本轨道  │   │视觉轨道  │   │音频轨道  │           │ │
│  │  │ Text     │   │ Visual   │   │ Audio    │           │ │
│  │  │ Track    │   │ Track    │   │ Track    │           │ │
│  │  ├──────────┤   ├──────────┤   ├──────────┤           │ │
│  │  │ 替换式   │   │ 图层叠加 │   │ 多通道   │           │ │
│  │  │ 打字效果 │   │ 视频阻塞 │   │ 多重播放 │           │ │
│  │  └──────────┘   └──────────┘   └──────────┘           │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                               │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                   底层模块                              │ │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐             │ │
│  │  │LayerMgr  │  │ResourcePool│ │CacheMgr │             │ │
│  │  │- show    │  │- download │  │- save   │             │ │
│  │  │- hide    │  │- waitFor  │  │- load   │             │ │
│  │  └──────────┘  └──────────┘  └──────────┘             │ │
│  └─────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────┘
```

### 前端模块清单

| 模块 | 职责 | 核心方法 |
|------|------|---------|
| **DataManager** | SSE连接管理、事件接收 | `connect()`, `disconnect()` |
| **BufferController** | 缓冲控制（事件级缓冲策略）| `receive()`, `onBufferEmpty()` |
| **NarrativeQueue** | 叙事流程调度（阻塞/非阻塞控制）| `enqueue()`, `pause()`, `resume()` |
| **TextTrack** | 文本轨道（对话/旁白/菜单）| `showDialogue()`, `showMenu()`, `waitForClick()` |
| **VisualTrack** | 视觉轨道（场景/图像/视频）| `setScene()`, `showCharacter()`, `playVideo()` |
| **AudioTrack** | 音频轨道（语音/音乐/音效/环境音）| `playVoice()`, `playMusic()`, `playSound()` |
| **ResourcePool** | 资源下载（并发控制、自动重试）| `download()`, `waitFor()` |
| **LayerManager** | 图层管理（显示/隐藏元素）| `showElement()`, `hideElement()` |
| **CacheManager** | IndexedDB 缓存管理 | `save()`, `load()`, `clear()` |

### 叙事队列调度机制

```
┌─────────────────────────────────────────────────────────────┐
│  NarrativeQueue 处理流程                                     │
│                                                              │
│  核心机制：叙事锁（NarrativeLock）                           │
│  ┌─────────────────────────────────────────────────────────┐│
│  │ 依次取出事件:                                           ││
│  │  ├─ 非叙事事件 → 直接执行，立即处理下一个               ││
│  │  └─ 叙事事件 → 等待叙事锁释放 → 执行 → 加锁             ││
│  └─────────────────────────────────────────────────────────┘│
│                                                              │
│  示例: [narration, play_audio, play_audio, dialogue]        │
│                                                              │
│  1. narration → 叙事锁已释放 → 执行 → 加锁                   │
│  2. play_audio → 非叙事 → 直接执行（与旁白同时播放）         │
│  3. play_audio → 非叙事 → 直接执行（与旁白同时播放）         │
│  4. dialogue → 等待叙事锁释放（用户点击/AFM）                │
│  5. 叙事锁释放 → dialogue 执行 → 加锁                        │
└─────────────────────────────────────────────────────────────┘
```

### 解耦设计：事件 → 资源 → 轨道

```
事件 ──包含──► 资源 ──映射──► 轨道

dialogue 事件:
  ├─ text: "你好"     → TextTrack.showDialogue()
  ├─ voice: {...}     → AudioTrack.playVoice()
  └─ image: {...}     → VisualTrack.showCharacter()
```

#### 事件标签

| 事件类型 | narrative | 说明 |
|---------|-----------|------|
| dialogue | `true` | 对话，阻塞队列 |
| narration | `true` | 旁白，阻塞队列 |
| play_video | `false` | 播放视频，视觉轨道内替换式 |
| choice | `true` | 选项，阻塞队列 |
| scene_start | `false` | 场景开始 |
| play_audio | `false` | 播放音效 |
| ... | `false` | 其他事件 |

#### 资源类型 → 轨道映射

| 资源类型 | 轨道 | 播放方法 |
|---------|------|---------|
| text | TextTrack | showDialogue() / showNarration() |
| voice | AudioTrack | playVoice() |
| image | VisualTrack | showCharacter() |
| background | VisualTrack | setScene() |
| music | AudioTrack | playMusic() |
| ambient | AudioTrack | playAmbient() |
| sound/audio | AudioTrack | playSound() |
| video | VisualTrack | playVideo() |

**核心原则**：事件只定义资源，不关心轨道；资源类型决定分发到哪个轨道。

---

## 后端架构

### 核心模块架构

```
┌─────────────────────────────────────────────────┐
│              FastAPI 服务                        │
│  ┌──────────────────────────────────────┐       │
│  │         API 路由层                    │       │
│  │  ┌──────┐ ┌──────┐ ┌──────┐         │       │
│  │  │故事API│ │用户API│ │选择API│        │       │
│  │  └──────┘ └──────┘ └──────┘         │       │
│  └──────────────────────────────────────┘       │
│                                                  │
│  ┌──────────────────────────────────────┐       │
│  │      SSE 推送服务                     │       │
│  │  ┌─────────────────────────────┐     │       │
│  │  │  SSEStreamManager           │     │       │
│  │  │  - XREAD block 阻塞等待     │     │       │
│  │  │  - 断点续传支持             │     │       │
│  │  │  - 心跳包维护               │     │       │
│  │  └─────────────────────────────┘     │       │
│  └──────────────────────────────────────┘       │
│                                                  │
│  ┌──────────────────────────────────────┐       │
│  │      AI 生成引擎                      │       │
│  │  ┌─────────────────────────────┐     │       │
│  │  │  AIStoryGenerator           │     │       │
│  │  │  - Prompt Engineering       │     │       │
│  │  │  - 流式生成剧本             │     │       │
│  │  │  - 脚本解析                 │     │       │
│  │  └────────┬────────────────────┘     │       │
│  │           │                           │       │
│  │  ┌────────▼────────────────────┐     │       │
│  │  │  NarrativeEventGenerator     │     │       │
│  │  │  - generate_scene_start()   │     │       │
│  │  │  - generate_dialogue()      │     │       │
│  │  │  - generate_narration()     │     │       │
│  │  │  - generate_play_audio()    │     │       │
│  │  └────────┬────────────────────┘     │       │
│  └───────────┼──────────────────────────┘       │
│              │                                    │
│  ┌───────────▼──────────────────────────┐       │
│  │      资源生成器                       │       │
│  │  ┌──────────┐ ┌──────────┐          │       │
│  │  │图像生成  │ │语音合成  │          │       │
│  │  │(AIGC)    │ │(TTS)     │          │       │
│  │  └──────────┘ └──────────┘          │       │
│  │  ┌──────────┐                        │       │
│  │  │CDN上传   │                        │       │
│  │  └──────────┘                        │       │
│  └───────────────────────────────────────┘      │
│                                                  │
│  ┌──────────────────────────────────────┐       │
│  │      Redis Stream 管理器              │       │
│  │  ┌─────────────────────────────┐     │       │
│  │  │  RedisStreamManager         │     │       │
│  │  │  - push_event()             │     │       │
│  │  │  - get_events_since()       │     │       │
│  │  │  - 消息持久化               │     │       │
│  │  └─────────────────────────────┘     │       │
│  └──────────────────────────────────────┘       │
└──────────────────────────────────────────────────┘
```

---

## 核心交互流程

### 故事生命周期概述

故事的完整生命周期分为两个阶段：

| 阶段 | 说明 | 触发条件 |
|------|------|---------|
| **Create（创作）** | 用户提供创意 → AI生成思考规划和大纲脚本 | 用户提交创意输入 |
| **Play（消费）** | 用户观看/互动 → AI动态生成情节和资源 | 用户开始消费故事 |

消费阶段包含两种行为模式：

| 行为模式 | 适用场景 | 说明 |
|---------|---------|------|
| **观看/播放** | 线性叙事（任何状态）、互动叙事已完成版本 | 被动观看，内容已确定 |
| **试玩** | 互动叙事未完成版本 | 主动探索，用户选择影响剧情走向 |

```
┌─────────────────────────────────────────────────────────────────────┐
│                          故事生命周期                                │
│                                                                      │
│  ┌──────────────────────┐      ┌──────────────────────────────────┐ │
│  │   Create（创作阶段）  │      │       Play（消费阶段）            │ │
│  │                      │      │                                  │ │
│  │  用户提供创意        │      │  ┌────────────┬────────────────┐ │ │
│  │       ↓              │      │  │ 观看/播放  │     试玩       │ │ │
│  │  AI 思考规划         │ ───► │  ├────────────┼────────────────┤ │ │
│  │       ↓              │      │  │ 线性叙事   │ 互动叙事       │ │ │
│  │  AI 生成大纲脚本     │      │  │ 已完成版本 │ 探索中版本     │ │ │
│  │       ↓              │      │  └────────────┴────────────────┘ │ │
│  │  状态: generating    │      │                                  │ │
│  └──────────────────────┘      └──────────────────────────────────┘ │
│                                                                      │
│  状态流转:                                                           │
│  pending ──Create──► generating ──Play──► dynamic/completed         │
└─────────────────────────────────────────────────────────────────────┘
```

**行为模式判定规则**：

| 故事类型 | 版本状态 | 行为模式 | 可分享 |
|---------|---------|---------|--------|
| linear | 任何状态 | 观看/播放 | ✅ 始终可分享 |
| interactive | 版本到达 story_end | 观看/播放 | ✅ 该版本可分享 |
| interactive | 版本未到达终点 | 试玩 | ❌ 仅创作者可访问 |

---

### 1. Create 阶段（创作）

用户提交创意，AI 生成思考规划和大纲脚本。此阶段不生成详细内容和资源。

```
用户
  │
  ├─► POST /api/v1/story/create
  │     { prompt_id: "...", type: "interactive" }
  │
服务端
  │
  ├─► 创建故事记录（PostgreSQL，status='pending'）
  ├─► 启动 AI 创作任务（后台）
  ├─► 返回 story_id
  │
  └─► 后台任务：
        ├─► AI 思考规划（保存到 stories.think）
        │     - 分析创意核心
        │     - 规划故事结构
        │     - 设计角色弧光
        │
        ├─► AI 生成大纲脚本（保存到 stories.script）
        │     - 章节划分
        │     - 关键剧情点
        │     - 分支设计（互动叙事）
        │
        └─► 更新状态为 'generating'（Create 完成，等待用户开始消费）
```

**Create 阶段产出**：
- `stories.think`：AI 思考规划内容
- `stories.script`：结构化大纲脚本
- `status = 'generating'`：等待消费

---

### 2. Play 阶段（消费）

用户开始消费故事，AI 根据大纲动态生成详细内容和资源。

#### 消费模式矩阵

| 故事类型 | 故事状态 | 行为模式 | 消费行为 |
|---------|---------|---------|----------|
| **linear** | pending | 观看/播放 | 首次观看：AI 流式生成全部内容 → completed |
| **linear** | completed | 观看/播放 | 重播：从数据库/Redis 读取已有事件 |
| **interactive** | pending | 试玩 | 首次试玩：AI 生成到第一个 choice → dynamic |
| **interactive** | dynamic | 试玩 | 继续试玩：用户选择 → AI 动态生成分支 |
| **interactive** | completed | 观看/播放 | 观看已完成版本，或继续试玩其他分支 |

---

#### 2.1 线性叙事消费流程（观看/播放）

**首次观看（status: pending → generating → completed）**

```
用户
  │
  ├─► GET /api/v1/story/{story_id}/stream
  │
服务端
  │
  ├─► 检查状态 = 'generating'（Create 已完成）
  ├─► 启动 AI 生成任务：
  │     ├─► 读取 stories.script（大纲）
  │     ├─► AI 流式生成详细剧本
  │     ├─► 解析为叙事事件
  │     ├─► 并发生成资源（图像、语音）
  │     ├─► 上传到 CDN
  │     └─► 双写：Redis Stream + 数据库
  │
  └─► SSE 实时推送事件

客户端
  │
  ├─► 接收事件 + 触发资源下载
  ├─► 资源缓存到 IndexedDB
  └─► 顺序播放事件
  
到达 story_end → 状态变为 'completed'
```

**重播（status: completed）**

```
用户
  │
  ├─► GET /api/v1/story/{story_id}/stream
  │
服务端
  │
  ├─► 检查状态 = 'completed'
  ├─► 检查 Redis Stream 是否存在
  │     ├─► 存在 → 直接读取
  │     └─► 不存在 → 从数据库加载 → 写入 Redis Stream
  │
  └─► SSE 快速推送所有事件

客户端
  │
  ├─► 快速接收所有事件（已生成，无等待）
  └─► 顺序播放事件
```

---

#### 2.2 互动叙事消费流程

##### 试玩模式（探索中）

**首次试玩（status: pending → generating → dynamic）**

```
用户
  │
  ├─► GET /api/v1/story/{story_id}/stream
  │
服务端
  │
  ├─► 检查状态 = 'generating'（Create 已完成）
  ├─► 启动 AI 生成任务：
  │     ├─► 读取 stories.script（大纲）
  │     ├─► AI 流式生成详细剧本
  │     ├─► 解析为叙事事件
  │     ├─► 并发生成资源
  │     └─► 双写：Redis Stream + 数据库
  │
  └─► SSE 推送事件，遇到 choice 暂停

遇到 choice 事件 → 状态变为 'dynamic'
```

**继续试玩（status: dynamic）**

```
用户选择分支
  │
  ├─► POST /api/v1/story/{story_id}/choice
  │     { option_id: "option_a" }
  │
服务端
  │
  ├─► 检查分支是否已生成
  │     ├─► 已生成 → 通过 next_sequence_id 继续推送
  │     └─► 未生成 → 触发 AI 动态生成：
  │           ├─► 创建新 path_id
  │           ├─► AI 生成该分支剧情
  │           ├─► 生成资源并上传
  │           └─► 双写：Redis Stream + 数据库
  │
  └─► SSE 继续推送新分支事件

到达 story_end → 该版本变为 'completed'，可分享为"观看/播放"模式
```

**断点续传（status: dynamic）**

```
用户
  │
  ├─► GET /api/v1/story/{story_id}/stream?from_sequence_id={seq_id}
  │
服务端
  │
  ├─► 从 seq_id 开始链式遍历推送事件
  ├─► 遇到 choice 事件 → 暂停推送，等待用户选择
  │     ├─► 用户可选择已探索的分支（复用）
  │     └─► 用户可选择未探索的分支（触发 AI 生成）
  │
  └─► SSE 推送事件

客户端
  │
  ├─► 接收事件并播放
  └─► 遇到 choice 显示选项，等待用户选择
```

##### 观看/播放模式（已完成版本）

当互动叙事的某个分支版本到达 `story_end` 后：

```
分支版本到达 story_end
  │
  ├─► 该版本状态变为 'completed'
  ├─► 创作者可选择分享该版本
  │
  └─► 分享后：
        ├─► 其他用户可访问该版本
        ├─► 消费模式为"观看/播放"（被动观看固定路径）
        └─► 不再触发 AI 动态生成
```

**观看已完成版本**

```
用户（观众）
  │
  ├─► GET /api/v1/story/{story_id}/version/{version_id}/stream
  │
服务端
  │
  ├─► 验证版本状态 = 'completed' 且已分享
  ├─► 从数据库/Redis 读取该版本的完整事件链
  │
  └─► SSE 推送事件（固定路径，无需选择）

客户端
  │
  ├─► 接收事件并播放
  └─► choice 事件自动按已选择的选项播放（无需用户选择）
```

---

#### Play 阶段状态流转

```
=== linear（线性叙事）- 始终为"观看/播放"模式 ===

         Create                     Play
pending ────────► generating ──首次观看──► completed
                      │                        │
                      └────────────────────────┴── 重播时直接读取

=== interactive（互动叙事）===

         Create                     Play
pending ────────► generating ──首次试玩──► dynamic（试玩模式）
                                              │
                     ┌────────────────────────┤
                     │                        │
                     ▼                        ▼
                继续试玩              到达 story_end
                （保持 dynamic）       → 该版本 completed
                                              │
                                              ▼
                                       可分享为"观看/播放"模式
                                       其他用户观看固定路径
```

**版本分享规则**：

| 场景 | 是否可分享 | 消费模式 |
|------|-----------|---------|
| 线性叙事（任何状态） | ✅ 始终可分享 | 观看/播放 |
| 互动叙事版本到达终点 | ✅ 可分享该版本 | 观看/播放 |
| 互动叙事版本探索中 | ❌ 不可分享 | 试玩（仅创作者） |

### 2. 事件播放流程

```
SSE推送事件
  ↓
DataManager 接收
  ↓
BufferController 接收：
  ├─► 立即触发资源下载（ResourcePool.download()）
  ├─► 加入事件缓冲区
  └─► 检查缓冲状态
  ↓
NarrativeQueue 顺序处理：
  ├─► 查询 EVENT_REGISTRY 获取事件元数据
  ├─► 分发到对应轨道（text/visual/audio）
  ├─► 检查 narrative 标签：
  │     ├─ true  → 阻塞队列（等待 AFM/用户点击）
  │     └─ false → 立即处理下一个事件
  └─► 叙事事件结束后执行清理
  ↓
队列空时通知 BufferController
```

**资源下载策略**：
- 并发限制：最多 6 个同时下载（可配置）
- 自动重试：失败自动重试 3 次
- 容错处理：下载失败不阻塞叙事，对应资源不显示

---

### 连接策略

故事的生命周期分为**创作阶段**和**消费阶段**，采用不同的连接策略以避免资源浪费：

```
┌──────────────────────────────────────────────────────────────────────┐
│                         故事生命周期                                  │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  【创作阶段】                    【消费阶段】                          │
│                                                                      │
│  POST /story/create             用户进入播放页                        │
│        │                              │                              │
│        ▼                              ▼                              │
│  ┌──────────┐                  ┌─────────────┐                       │
│  │ 短轮询    │                  │ 检查本地缓存 │                       │
│  │ 10秒/次  │                  └──────┬──────┘                       │
│  └────┬─────┘                         │                              │
│       │                         ┌─────┴─────┐                        │
│       │ status=ready            │           │                        │
│       │                       有缓存      无缓存                      │
│       ▼                         │           │                        │
│  ┌──────────┐                   ▼           ▼                        │
│  │ 进入消费 │             从缓存播放    建立 SSE                      │
│  │ 阶段     │                   │           │                        │
│  └──────────┘                   └─────┬─────┘                        │
│                                       │                              │
│                                       ▼                              │
│                              统一缓冲策略                             │
│                      ┌──────────────────────────────┐                │
│                      │  高水位 → 断开 SSE 节省流量   │                │
│                      │  低水位 → 重连 SSE 补充缓存   │                │
│                      └──────────────────────────────┘                │
└──────────────────────────────────────────────────────────────────────┘
```

#### 创作阶段：短轮询

| 配置项 | 值 | 说明 |
|--------|-----|------|
| 轮询间隔 | 10 秒 | 服务端可通过 `retry_after` 动态调整 |
| 查询接口 | `GET /story/{story_id}/status` | 轻量接口，只返回状态 |
| 结束条件 | `status != pending` | 进入消费阶段或处理错误 |

**优势**：
- ✅ 无需保持长连接，服务端资源零浪费
- ✅ 用户可离开页面，后台继续生成
- ✅ 支持多端同步（手机创建，电脑播放）

#### 消费阶段：统一缓冲策略

**核心理念**：首次观看和继续观看使用**完全相同的缓冲策略**，区别仅在于本地缓存的命中情况。

| 场景 | 缓存状态 | 行为 |
|------|---------|------|
| **首次观看** | 无缓存 | 建立 SSE，接收事件并缓存到 IndexedDB |
| **继续观看** | 有缓存 | 从缓存读取，缓存不足时 SSE 增量补充 |

**统一策略**：

| 策略 | 说明 |
|------|------|
| **统一 SSE 接口** | 所有故事使用 `GET /story/{story_id}/stream`，不区分生成中/已完成 |
| **本地缓存持久化** | 所有事件持久化到 IndexedDB（7 天过期） |
| **增量 SSE** | 缓存不足时建立 SSE，携带 `from_sequence_id` 增量接收 |
| **智能断开** | 缓存充足（高水位）时主动断开 SSE，节省 CDN 流量 |
| **智能重连** | 缓存即将耗尽（低水位）时自动重连 SSE |

**缓冲阈值**：

| 阈值 | 值 | 说明 |
|------|-----|------|
| 高水位 | 20 个叙事事件 | 达到后断开 SSE，节省流量 |
| 低水位 | 5 个叙事事件 | 低于后重连 SSE，确保流畅 |

**本地缓存策略**：

| 配置项 | 值 | 说明 |
|--------|-----|------|
| 过期时间 | 7 天 | 超过 7 天未访问的缓存自动清理 |
| 清理时机 | 应用启动时 | 后台静默清理过期数据 |
| 存储限制 | 按需 | 浏览器 IndexedDB 配额（通常 >50MB）|

**序幕加载（可选）**：

首次观看时，可以通过展示"序幕界面"掩盖初始缓冲：
- 显示故事标题、简介、主要角色
- 播放背景音乐预热氛围
- 后台同时进行 SSE 连接和事件缓冲
- 3-5 秒后序幕结束，无缝进入故事

**优势**：
- ✅ **统一逻辑**：首次/继续观看无需区分处理
- ✅ **秒播体验**：有缓存时立即播放
- ✅ **节省流量**：按需拉取，高水位断开
- ✅ **支持离线**：已缓存内容可离线播放
- ✅ **断点续传**：无缝衔接，用户体验一致

---

### 分支缓冲策略

线性叙事和互动叙事采用**统一的分支缓冲模型**，核心设计：

- **后端**：所有事件（包括所有分支）直接推送，事件自带 `path_id` 标识
- **前端**：维护 `currentPathId` 状态，只播放匹配的事件

```
┌─────────────────────────────────────────────────────────────────┐
│                    分支缓冲模型                                  │
│                                                                  │
│  后端推送（所有分支事件）                                         │
│       │                                                          │
│       ▼                                                          │
│  前端接收事件                                                     │
│       │                                                          │
│       ├─► 立即下载资源（无论哪个分支）                            │
│       │                                                          │
│       ├─► 判断 event.path_id === currentPathId ?                │
│       │     ├─ ✅ 匹配 → 加入 NarrativeQueue 播放                │
│       │     └─ ❌ 不匹配 → 忽略（资源已下载）                     │
│       │                                                          │
│  用户选择分支时                                                   │
│       │                                                          │
│       └─► 切换 currentPathId = 选中分支的 path_id               │
│           后续匹配的事件立即播放（资源已就绪，无延迟）             │
└─────────────────────────────────────────────────────────────────┘
```

#### 类型差异

| 故事类型 | currentPathId | 行为 |
|---------|---------------|------|
| 线性叙事 | 恒为 `"root0000"` | 所有事件都匹配，顺序播放 |
| 互动叙事 | 初始 `"root0000"`，选择后切换 | 只播放当前路径，其他分支资源预下载 |

#### 并行分支预生成

后端遇到 choice 事件后，**并行生成所有分支**并直接推送：

```
后端生成流程：
  ├─► root0000: seq_1 → seq_2 → choice_1 ──推送──► 前端播放
  │       │
  │       ├─► 并行生成分支 A、B、C
  │       │
  ├─► a1b2c3d4: seq_a1 → seq_a2 → choice_2a ──推送──► 前端预下载资源（不播放）
  ├─► e5f6g7h8: seq_b1 → story_end ──推送──► 前端预下载资源（不播放）
  └─► i9j0k1l2: seq_c1 → seq_c2 → choice_2c ──推送──► 前端预下载资源（不播放）

用户选择 option_a 后：
  └─► currentPathId = "a1b2c3d4"
      后续 a1b2c3d4 的事件立即播放（资源已就绪）
```

#### 预生成深度控制

```
配置参数：
  - branch_prefetch_depth: 1     # 预生成层数（默认1层，到下一个 choice 暂停）
  - max_parallel_branches: 3     # 最大并行分支数
```

| 场景 | 行为 |
|------|------|
| 遇到 choice 事件 | 不阻塞，为所有选项并行预生成 |
| 分支生成到下一个 choice | 该分支暂停，等待用户进入后继续 |
| 分支生成到 story_end | 该分支完成 |
| 用户选择某分支 | 前端切换 currentPathId，继续该分支的预生成 |

#### 优势

- ✅ **极简设计**：后端无需改动，前端只需一个状态变量
- ✅ **零延迟**：资源提前下载，选择后立即播放
- ✅ **统一模型**：线性叙事和互动叙事使用相同逻辑
- ✅ **资源可控**：预生成深度可配置，防止过度下载

### 3. 用户选择流程

```
收到 choice 事件（path_id 匹配当前路径）
  ↓
前端显示选择UI，暂停播放队列
（SSE 持续推送其他分支事件，前端预下载资源但不播放）
  ↓
用户点击选项（如 option_a，对应 path_id: "a1b2c3d4"）
  ↓
前端切换状态：currentPathId = "a1b2c3d4"
  ↓
判断分支事件是否已接收：
  │
  ├─► 已接收（分支已预生成并推送）
  │    └─► 资源已下载，立即恢复播放（零延迟）
  │
  └─► 未接收（分支未生成或正在生成中）
       └─► 等待 SSE 推送该 path_id 的事件
           后端继续生成 → 推送 → 前端接收后播放
  ↓
POST /api/v1/story/{story_id}/choice {option_id: "option_a"}
  ↓
后端处理：
  ├─► 记录用户选择（更新 progress、version 等）
  ├─► 如分支未生成，触发 AI 动态生成：
  │    ├─ 创建新 path_id（如 "a1b2c3d4"）
  │    ├─ 生成事件并设置 path_id 和 next_sequence_id
  │    ├─ 双写：Redis Stream + 数据库
  │    └─ SSE 推送新生成的事件
  └─► 如分支已生成，确认预生成继续（从暂停的 choice 恢复）
```

**分支生成策略**：
- **预生成**：遇到 choice 后并行生成所有分支，直接推送
- **按需生成**：预生成深度受限，超出部分在用户选择后继续生成
- **缓存复用**：已生成的分支存储在数据库，其他用户可直接复用

### 事件树数据结构示例

**线性故事**：
```
story_id: story_001
path_id: root0000 (唯一路径)

┌─────────────────────────────────────────────────┐
│ seq_1 (01JG8XYZ001) story_start                 │
│   next_sequence_id → 01JG8XYZ002                │
├─────────────────────────────────────────────────┤
│ seq_2 (01JG8XYZ002) dialogue                    │
│   next_sequence_id → 01JG8XYZ003                │
├─────────────────────────────────────────────────┤
│ seq_3 (01JG8XYZ003) dialogue                    │
│   next_sequence_id → 01JG8XYZ004                │
├─────────────────────────────────────────────────┤
│ seq_4 (01JG8XYZ004) story_end                   │
│   next_sequence_id → NULL                       │
└─────────────────────────────────────────────────┘
```

**分支故事**：
```
story_id: story_001

主路径 (path_id: root0000)
┌─────────────────────────────────────────────────┐
│ seq_1 (01JG8XYZ001) story_start                 │
│   next → 01JG8XYZ002                            │
├─────────────────────────────────────────────────┤
│ seq_2 (01JG8XYZ002) dialogue                    │
│   next → 01JG8XYZ003                            │
├─────────────────────────────────────────────────┤
│ seq_3 (01JG8XYZ003) choice                      │
│   next → NULL                                   │
│   options:                                      │
│     - option_a.next → 01JG8Y12ABC (分支A起点)   │
│     - option_b.next → 01JG8Y34DEF (分支B起点)   │
└─────────────────────────────────────────────────┘
                 │                 │
        ┌────────┴────────┐        │
        ▼                 │        ▼
分支A (path_id: a1b2c3d4)│  分支B (path_id: e5f6g7h8)
┌──────────────────┐     │  ┌──────────────────┐
│ seq_1 dialogue   │     │  │ seq_1 dialogue   │
│   next → ...     │     │  │   next → ...     │
├──────────────────┤     │  ├──────────────────┤
│ seq_2 dialogue   │     │  │ seq_2 choice     │
│   next → ...     │     │  │   options:       │
├──────────────────┤     │  │     - c.next→... │
│ seq_3 story_end  │     │  │     - d.next→... │
│   next → NULL    │     │  └──────────────────┘
└──────────────────┘     │         │      │
                         │    ┌────┘      └────┐
                         │    ▼                ▼
                         │  分支C          分支D
                         │  (c9d0e1f2)    (g3h4i5j6)
```

**查询示例**：
```sql
-- 1. 查询故事起点
SELECT * FROM story_events 
WHERE story_id='story_001' AND event_type='story_start';
-- 返回：01JG8XYZ001 (story_start)

-- 2. 链式查询下一个事件
SELECT * FROM story_events 
WHERE sequence_id='01JG8XYZ002';
-- 返回：dialogue 事件

-- 3. 遇到 choice，用户选择 option_a，跳转到分支A
-- 从 choice.content.options 中获取 next_sequence_id='01JG8Y12ABC'
SELECT * FROM story_events 
WHERE sequence_id='01JG8Y12ABC';
-- 返回：分支A的第一个事件 (path_id=a1b2c3d4)
```

---

## 叙事队列 + 媒体轨道机制

### 核心原则

| 组件 | 职责 | 阻塞规则 |
|------|------|---------|
| **NarrativeQueue** | 叙事流程调度 | narrative=true 阻塞队列，=false 立即继续 |
| **TextTrack** | 文本渲染 | 替换式（同时只显示一段）|
| **VisualTrack** | 视觉播放 | 场景替换、图像叠加、视频阻塞 |
| **AudioTrack** | 音频播放 | 单播通道替换、sound通道多重 |

### 叙事锁机制示例

```
事件队列: [narration("爆炸声传来"), play_audio(爆炸), play_audio(碎玻璃), dialogue]

时间线:
─────────────────────────────────────────────────────────────►

T0: narration → 叙事锁释放 → 执行 → 【加锁】
    ├─ 同时: play_audio(爆炸) → 非叙事 → 直接执行
    ├─ 同时: play_audio(碎玻璃) → 非叙事 → 直接执行
    └─ dialogue → 等待叙事锁...

T1: 用户点击/AFM → 【释放锁】
    └─ dialogue → 执行 → 【加锁】
```

**关键点**：非叙事事件永不阻塞，叙事事件之间通过"叙事锁"串行

---

## 媒体轨道规则

### 音频通道设计

| 通道 | 播放模式 | 特性 |
|------|---------|------|
| `voice` | 替换式 | 新语音停止旧语音 |
| `music` | 替换式 | 循环播放，支持淡入淡出 |
| `ambient` | 替换式 | 循环播放，场景切换时自动清理 |
| `sound` | 多重播放 | 即发即忘，可同时播放多个 |

### 时序图

```
时间轴 →
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

叙事队列：
├─ dialogue_1 ──────────────────┬─ dialogue_2 ─────────────────┤
│  [叙事锁]                     │  [叙事锁]                     │
│                               │                              │
│  资源分发:                    │  资源分发:                    │
│  ├─ text → TextTrack          │  ├─ text → TextTrack          │
│  ├─ voice → AudioTrack        │  ├─ voice → AudioTrack        │
│  └─ image → VisualTrack       │  └─ image → VisualTrack       │
│              ↓ AFM/用户点击   │              ↓ AFM/用户点击   │
│                               │                              │

非叙事事件（不阻塞，与叙事事件同时播放）：
├─ play_audio(脚步) ════════    │               │              │
│      ↑                        │  play_audio(门声) ═════      │
│      └─ 即发即忘              │       ↑                      │
│                               │       └─ 与对话同时播放      │
```

---

## 媒体资源支持

### 支持的媒体类型

| 类型 | 格式 | 用途 | 特性 |
|------|------|------|------|
| **静态图像** | PNG, JPG, WebP | 背景、角色立绘 | 透明通道（PNG/WebP）|
| **动态图像** | GIF, APNG, WebP动画 | 动态立绘、特效 | 循环播放 |
| **视频** | WebM, MP4 | 动态背景、过场动画 | WebM支持透明通道 |
| **Live2D** | model3.json | 角色互动动画 | 呼吸、眨眼等微动作 |
| **音频** | OGG, MP3 | 音乐、音效、配音 | OGG推荐（体积小）|

### 透明图层支持

```
图层系统（从下到上）：
━━━━━━━━━━━━━━━━━━━━━━━
Layer 5: UI层（对话框、选择UI）
Layer 4: 特效层（透明特效）
Layer 3: 角色层（透明PNG/WebM）
Layer 2: 道具层（透明元素）
Layer 1: 背景层（不透明）
━━━━━━━━━━━━━━━━━━━━━━━
```

---

## 用户行为记录策略

系统记录用户与故事的交互行为，用于运营统计和个性化推荐。

### 行为类型

| 行为 | 说明 | 记录时机 |
|------|------|----------|
| `create` | 创建故事 | `POST /story/create` 时 |
| `enter` | 进入故事 | SSE 连接建立时 |
| `exit` | 退出故事 | `POST /story/{id}/progress` 保存进度时 |
| `complete` | 完成故事 | 后端推送 `story_end` 事件时 |
| `like` / `unlike` | 点赞/取消 | `POST/DELETE /story/{id}/like` |
| `favorite` / `unfavorite` | 收藏/取消 | `POST/DELETE /story/{id}/favorite` |
| `share` | 分享故事 | `POST /story/{id}/share` |
| `choice` | 选择分支 | 后端处理分支选择请求时 |

### 游客 vs 登录用户

| 功能 | 游客 | 登录用户 |
|------|------|----------|
| **浏览** | ✅ 广场浏览、故事详情 | ✅ |
| **播放** | ✅ 可播放故事 | ✅ |
| **互动** | ❌ 点赞、收藏需登录 | ✅ |
| **分享** | ✅ 可分享（不记录行为）| ✅（记录行为）|
| **进度** | ❌ 不保存服务端进度 | ✅ 保存并同步 |
| **创作** | ❌ 需登录 | ✅ |
| **推荐** | ❌ 无个性化推荐 | ✅ 基于行为推荐 |
| **行为记录** | ❌ 不记录 | ✅ 完整记录 |

### 记录策略

```
┌─────────────────────────────────────────────────────────────┐
│                    用户行为记录策略                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  游客用户：                                                  │
│  ├─► 可浏览、播放、分享                                      │
│  ├─► 不记录行为到 user_behavior_logs                        │
│  ├─► 仅更新故事表计数（play_count、share_count）             │
│  └─► 本地可使用 localStorage 缓存偏好设置                    │
│                                                             │
│  登录用户：                                                  │
│  ├─► 完整功能访问                                            │
│  ├─► 所有行为记录到 user_behavior_logs                      │
│  ├─► 同时更新用户表和故事表的统计计数                        │
│  └─► 设置同步到服务端 users.settings                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 本地缓存策略

| 数据类型 | 游客 | 登录用户 | 说明 |
|----------|------|----------|------|
| **播放设置** | localStorage | 服务端同步 | 音量、文字速度等 |
| **播放进度** | localStorage | 服务端同步 | 当前事件位置 |
| **故事事件** | IndexedDB | IndexedDB | 7天过期，提升播放体验 |

**注意**：
- 游客的本地缓存仅在当前设备有效
- 登录后**不迁移**游客的本地数据（避免数据冲突）
- 登录用户的设置和进度以服务端为准

### 统计计数更新

| 行为 | 用户表更新 | 故事表更新 |
|------|-----------|-----------|
| `create` | `create_count +1` | - |
| `enter` | `view_count +1` | `play_count +1` |
| `like` | `like_count +1` | `like_count +1` |
| `unlike` | `like_count -1` | `like_count -1` |
| `favorite` | `favorite_count +1` | `favorite_count +1` |
| `unfavorite` | `favorite_count -1` | `favorite_count -1` |
| `share` | `share_count +1` | `share_count +1` |

> 游客行为仅更新故事表计数，不更新用户表（无 user_id）。

---

## 技术栈总览

### 后端技术栈

| 技术 | 用途 | 版本 |
|------|------|------|
| Python | 主语言 | 3.11+ |
| FastAPI | Web框架 | 0.104+ |
| Redis | 消息队列 | 7.0+ |
| PostgreSQL | 数据库 | 15+ |
| redis.asyncio | Redis客户端 | 5.0+ |
| OpenAI SDK | AI调用 | 1.3+ |

### 前端技术栈

| 技术 | 用途 | 版本 |
|------|------|------|
| React | UI框架 | 18+ |
| TypeScript | 类型系统 | 5.0+ |
| Zustand | 状态管理 | 4.4+ |
| Howler.js | 音频管理 | 2.2+ |
| IndexedDB | 本地缓存 | - |
| Vite | 构建工具 | 5.0+ |

---

## 核心优势

### 1. 清晰的职责分离
- **后端**：关注业务逻辑（scene_start, dialogue...）
- **前端**：关注技术实现（show, play, say...）

### 2. 自动状态管理
- 场景切换自动清理
- 对话结束自动隐藏
- 无需手动管理状态

### 3. 优雅的异步机制
- 资源下载完全并行
- 事件执行严格顺序
- 基于协程，非轮询

### 4. 良好的扩展性
- 添加新叙事事件：定义接口 + 后端生成 + 前端解析
- 修改渲染逻辑：仅前端修改，不影响后端
- AI 友好：叙事事件更易理解

### 5. 与 Ren'Py 对应

| Ren'Py 脚本 | 本系统事件 | narrative |
|-------------|-----------|-----------|
| `voice "..." + alice "..."` | `dialogue` | `true`（阻塞）|
| `"旁白文本"` | `narration` | `true`（阻塞）|
| `menu:` | `choice` | `true`（阻塞）|
| `scene laboratory` | `scene_start` | `false` |
| `show alice at center` | dialogue 事件包含 image 资源 | - |
| `hide alice` | 叙事事件结束后自动隐藏 | - |
| `play sound "door.ogg"` | `play_audio` | `false` |
| `play music "bgm.ogg"` | `play_audio` (channel: music) 或 scene_start 包含 music | `false` |

---

## 商业化与激励体系

本系统引入"灵感值"虚拟货币机制，用于控制 AIGC 生成成本并激励优质创作者。

### 灵感值（虚拟货币）

灵感值是平台内的通用货币，用于：
- **消费**：购买付费故事、打赏创作者
- **充值**：用户通过第三方支付购买灵感值
- **收入**：创作者通过故事销售和打赏获得灵感值

### 用户级别体系

用户通过创作和互动积累经验值，提升级别解锁更多权益：

| 级别 | 经验值要求 | 权益 |
|------|-----------|------|
| 1 | 0 | 基础创作（每日限额 5 次）|
| 2 | 100 | 提升创作限额至 10 次/日 |
| 3 | 500 | 提升创作限额至 20 次/日 |
| 4 | 1500 | **解锁故事定价权** |
| 5 | 5000 | 更高分成比例（75%）|
| 6+ | ... | 更多高级功能 |

### 经验值获取

| 行为 | 经验值 |
|------|--------|
| 每日签到 | +5 |
| 完成一个故事创作 | +20 |
| 故事被播放（每100次）| +10 |
| 故事被点赞 | +2 |
| 故事被收藏 | +3 |

### 故事定价类型

| 类型 | 说明 |
|------|------|
| `free` | 免费（默认）|
| `paid` | 付费（需一次性支付全部价格）|

### 收益分成

- **付费故事**：创作者获得 70% 收入（level 5+ 为 75%）
- **打赏**：创作者获得 100%（平台不抽成打赏）
- 平台抽成用于运营和算力成本

### 相关接口

- `GET /user/wallet` - 获取钱包信息
- `GET /user/wallet/transactions` - 获取交易记录
- `POST /user/wallet/recharge` - 充值灵感值
- `POST /story/{story_id}/purchase` - 购买故事
- `POST /story/{story_id}/tip` - 打赏创作者
- `PATCH /story/{story_id}/pricing` - 设置故事定价
- `POST /user/daily-checkin` - 每日签到

详见 [api.md](./api.md) 用户模块和故事模块。

---

## 待办事项 (TODO)

### 1. 创作者编辑权与精修工具
- [ ] **人工编辑模式**：允许创作者在 `Create` 阶段生成的 `script`（大纲）基础上进行人工修改。
- [ ] **资源手动替换**：支持创作者上传自定义立绘、背景、音乐，或对 AI 生成结果进行重绘（Redraw）。
- [ ] **剧情锚点**：支持设置强制剧情节点，引导 AI 在约束条件下生成内容。

### 2. 内容安全审核机制
- [ ] **双重审核流**：接入内容安全 API，对用户输入（Prompt）和 AI 输出（文本/图片）进行实时合规性审核。
- [ ] **举报与风控后台**：建立用户举报机制和人工审核管理后台。

### 3. 内容发现与标签系统
- [ ] **世界观/词条系统**：支持跨故事共享世界观设定。
- [ ] **精细化标签自动提取**：AI 自动提取剧情标签（如：反转、虐恋、治愈等），提升搜索和推荐精度。

### 4. 商业化与成本管理
- [ ] **定价策略优化**：引入动态定价、限时折扣、捆绑销售等灵活定价机制。
- [ ] **订阅会员体系**：设计月度/年度会员，提供无限创作、优先体验、专属徽章等权益。
- [ ] **广告变现**：在免费故事中插入合适的广告位（如章节间隙、结局后），创作者可获得分成。
- [ ] **提现系统**：支持创作者将灵感值余额提现为真实货币（需实名认证）。
- [ ] **财务报表**：为创作者提供收益统计、流水明细、税务报告等财务工具。

### 5. 社区社交与分支共创
- [ ] **私信系统**：支持用户与创作者之间的私聊互动。
- [ ] **分支共创（接龙）**：允许用户在他人公开的故事节点上开启并发布新的分支。

### 6. 创作者数据分析工具
- [ ] **流失漏斗分析**：提供“剧情流失图”，展示用户在不同分支路径上的分布和跳出率。

---

## 项目愿景：定义全新的数字娱乐品类

本项目不仅仅是一个视觉小说播放器，我们的目标是利用 AIGC 技术，打破传统叙事的边界，将人类的精神娱乐活动带向 **Next Level** —— 创造一种如同“清明梦（Lucid Dreaming）”般的体验。

### 1. 从“选择题”到“开放式交互” (Natural Language Interaction)
打破预设的 A/B 选项限制，允许玩家通过自然语言直接与角色、世界进行实时交互。AI 不再是死板地执行剧本，而是根据玩家的行为进行逻辑博弈，动态涌现出独一无二的故事响应。

### 2. 赋予角色“数字生命” (Agent Agency & Persistent Memory)
NPC 不再是随用随弃的“工具人”，而是拥有独立记忆、性格演化能力的数字生命体。他们在不同的故事线甚至跨越不同的游玩周期中保留对玩家的情感记忆，构建真正深度的羁绊。

### 3. 共享宇宙与“蝴蝶效应” (Shared Multi-verse)
从单机闭环进化为多人共享的叙事现实。玩家的选择将作为“公共事件”永久改变世界线的走向，影响后续进入该宇宙的所有玩家，共同构建一个持续生长的动态文明史。

### 4. 跨越屏幕的现实链接 (Augmented Narrative Reality)
模糊虚拟与现实的界限。AI 角色可以根据真实世界的环境、时间，甚至通过即时通讯工具与玩家互动，让故事不再局限于屏幕之内，而是无缝编织进玩家的日常生活。

### 5. 广告生长 (Organic Brand Integration)
颠覆传统的"广告植入"模式，让品牌与商品**生长于故事之中**，成为叙事不可分割的一部分。正如《四驱兄弟》让田宫四驱车成为一代人的童年符号，《繁花》让和平饭店、黄河路的烟火气重新点燃——这些品牌从未"投放广告"，却在观众心中留下了远超广告的深刻印记。

AIGC 驱动的互动叙事为这种"故事原生品牌"提供了前所未有的可能性：
- **场景共生**：咖啡馆、酒店、街道可以作为故事的核心场景，玩家在情感高潮中与这些空间建立记忆锚点
- **道具叙事**：一辆车、一款手表、一件衣服可以成为推动剧情的关键道具，承载角色的情感与成长
- **文化符号**：品牌不再是冰冷的 Logo，而是被赋予故事意义的文化符号，与玩家共同经历冒险、爱情、成长

这不是广告，这是**让品牌成为故事的一部分，让故事成为品牌的灵魂**。
